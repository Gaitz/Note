## Working Effectively with Legacy Code, Michael C. Feathers

### Working Effectively with Legacy Code, 中文版, ComputerScience/Mindset

---

Part I 修改機制

第一章 - 修改軟體

第二章 - 帶著回饋工作

第三章 - 感測與分離

第四章 - 接縫模型

第五章 - 工具

Part II 修改程式碼的技術

第六章 - 時間緊迫，但必須修改

第七章 - 漫長的修改

第八章 - 添加特性

第九章 - 無法將類別放入測試控制工具之中

第十章 - 無法在測試控制工具中執行方法

第十一章 - 修改時應當測試哪些方法

第十二章 - 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴

第十三章 - 修改時應該怎樣寫測試

第十四章 - 棘手的函式庫依賴問題

第十五章 - 到處都是 API 呼叫

第十六章 - 對程式碼的理解不足

第十七章 - 程式毫無結構可言

第十八章 - 測試程式碼礙手礙腳

第十九章 - 對非物件導向的專案，如何安全地對它進行修改

第二十章 - 處理大類別

第二十一章 - 需要修改大量相同的程式碼

第二十二章 - 要修改一個巨型方法，卻沒辦法為它編寫測試

第二十三章 - 降低修改的風險

第二十四章 - 當你感到絕望時

Part III 解依賴技術

第二十五章 - 解依賴技術

第二十六章 - Appendix 重構

---

Part I 修改機制

---

### 第一章 - 修改軟體

- 保持既有行為不變是軟體開發中最據挑戰性的任務之一
- 危險的修改, 修改程式是必定發生的, 壞的架構與好的架構, 取決於易讀性與讀完後對修改的信心程度
- 修改是需要時常練習的

---

### 第二章 - 帶著回饋工作

- Edit and Pray vs. Cover and Modify
- 把要修改的部份使用測試覆蓋 (Cover) 來驗證變動
- End-to-End Test 作用於 Application layer 執行速度太慢了, 不利於開發驗證
- 使用單元測試與重構, 清晰化要修改的邏輯並且有測試保護 (驗證變動與協助理解功能)

2.1 單元測試

- 單元測試, 測試最基本單位的元件, 例如函式 (function), 類別 (class)
- 測試的隔離性, 廣泛規模的大型測試 (整合測試 integration test), 有其價值但是也有些問題
  - 錯誤定位, 當錯誤發生時不容易找出錯誤發生點
  - 執行時間過長, 導致無法頻繁的執行
- 好的單元測試, 要具備執行速度快, 能協助定位錯誤發生點, (短小易理解, 協助錯誤定位)
- 為測試分類, 每種測試類型都有他的好處, 但是不能混用導致錯誤的使用時機
- 單元測試不應該
  - 與資料庫互動
  - 含有 Networking
  - 接觸檔案系統
  - 需要額外對環境設定

2.3 測試覆蓋

- 為遺留程式碼進行修改時添加測試的方法
- 為了針對將要修改的內容添加測試, 有可能會需要一般小心的做重構 (去耦合) 讓測試容易撰寫
- 策略 1. 加入界面隔離 (Extract Interface)
- 策略 2. 添加精簡的傳入值, (Primitive Parameter)
- 程式可能變醜, 但是更容易測試更安全, 在未來再進行重構

2.4 遺留程式碼修改演算法

- 修改遺留程式碼的流程
1. 確定變動點
   - 閱讀程式碼, 增加理解程度找出正確的修改地點
1. 找出測試點
   - 針對變動點找出編寫測試的位置
1. 解依賴
   - 為了容易在測試中實例化 (instance)
   - 容易執行要測試的函式
1. 編寫測試
1. 實際修改與重構
   - 推薦使用 Test-driven development (TDD) 來添加新功能

---

### 第三章 - 感測與分離

- **利用測試感測程式的影響範圍與效用**
- 為了測試所需要解耦合的兩個原因
  - 感測, 無法取得回傳值時 (無法測試驗證)
  - 分離, 無法把一部分程式碼納入測試中時 (無法撰寫單元測試)

3.1 偽裝成合作者 (mocking)

- 建立 fake object, fake function 來 mocking, 實現**分離**來撰寫單元測試
- 為了建立 fake collaborators 需要進行重構, 利用界面分離, 分割成子函式等方式
- fake collaborators 上可以擴充界面新增一些回傳值, 函式來協助測試， 達到**感測**  
- 應該要撰寫簡單, 並且能有效測試

---

### 第四章 - 接縫模型

- 可測試的程式碼
- 越熟練實作可測試的程式碼, 會對於好的程式架構有不同的看法
- 接縫 (seam) 是在不改變函式呼叫的情況下, 改變被呼叫的函式. 通常由引入中間層達成。用來作為解耦合的技巧
- 每個接縫 (seam) 都會有一個開關 (enabling point) 用來決定執行的行為 
- 試著思考接縫位置與其開關, 並且確保開關在 production 與 test 中是明顯可見的. 
- 使用接縫的目的在於盡少的修改遺留程式碼, 但是提供良好測試的機會

4.3 接縫類型

- 依據不同的程式語言類型, 尋找不同的接縫達成方式
- 預處理期接縫, 在編譯期之前的處理.
  - 例如 C/C++ 中的巨集處理, 可以用來實現接縫
- 連接期接縫, 在讀取函式庫時的連結, 轉換
  - 例如 Java 中以不同的 `classpath`  指定使用的函式庫
- 物件接縫, 存在於大多數的物件導向程式語言中

---

### 第五章 - 工具

5.1 自動化重構工具

- 在使用自動化重構工具前, 最好先進行測試, 確保重構工具能安全的重構
- 即使有自動化重構工具, 仍最好先擁有測試保護

5.2 Mock object

- 解依賴, 在測試時提供仿造的物件 (mock object)

5.3 單元測試控制工具

- xUnit 系列

5.4 一般測試控制工具

- 執行整合測試的工具
- 例如 FIT, Fitnesse

---

Part II 修改程式碼的技術

---

### 第六章 - 時間緊迫，但必須修改

- 修改前優先投資於測試
- 各種作法的重點都在於現有的架構無法納入測試, 但是新功能開發需使用測試保護.
- 從新功能一步一步的改進, 在熟悉舊架構的同時未來也有能力幫其撰寫測試

6.1 新生方法 (Sprout Method)

- 如果要添加的特性, 是可以使用全新的程式碼達成時, 建議直接建立新的方法, 然後引入.
- 新生方法更容易添加測試, 並且可以良好的分離不同的操作
- 撰寫程式碼時要一同思考是否清晰, 分離不同的邏輯
- 任何時候如果能使用新生方法 (新功能可以以獨立的程式碼實作) 時,  推薦優先使用

6.2 新生類別 (Sprout Class)

- 在新生方法無法實現時, 即新生方法必須能納入測試.
- 在舊的類別無法為了新生方法納入測試環境時, 為了新功能建立一個新的物件來達成可測試的新方法.
- 需要審視且建立好的新物件名稱與格式

6.3 外覆方法 (Wrap Method)

- 在一個方法裡添加新的程式碼, 通常是可疑的 (可能不符合單一責任原則). 
- 在擴充函式時, 可以把舊有的實作封裝成另外的函式, **保持原函式界面**, 但是呼叫舊的實作與新的實作函式
- 缺點在於函式命名可能不精確, 與安全的抽離舊有實作

6.4 外覆類別 (Wrap Class)

- 外覆方法的物件版, 即裝飾模式 (decorator pattern)
- 或者使用非裝飾性的外覆類別, 但是變成在呼叫時需要換成新物件的名稱, 仍然保持界面

---

### 第七章 - 漫長的修改

7.1 理解程式碼

- 維護良好與遺留系統中的差別在於程式碼理解的容易程度
- 沒辦法理解程式碼就沒辦法定位要修改的位置與影響程度

7.2 時滯 (lag time)

- 修改到反饋的時間
- 在解依賴後配合 TDD 可以達到順暢的反饋時間

7.3 解依賴 (decouple)

- 在物件導向中首先要能在測試工具中實體化類別, 然後測試個別的方法
- 建構依賴, 為了加速反饋時間 (編譯到執行的時間), 要歸屬依賴形成更小的單元 (package 或函式庫), 在檔案結構上也會跟著變化, 更清晰與迅速
- 使用界面隔離分離依賴實作
- 依賴反轉原則, 
  - 程式碼依賴的對象越少變化越好, 因此界面是比實作更適合依賴的方式

---

### 第八章 - 添加特性

- 把舊有程式納入測試保護才是系統最堅固的基石

8.1 測試驅動開發 (Test-driven development, TDD)

- 紅燈 -> 綠燈 -> 重構 loop
- Baby step

8.2 差異式程式設計 (Programming by difference)

- 在物件導向中使用繼承, 以子物件 override 的方式實現新功能並且保有測試
- 但是繼承在物件導向中是不可被濫用的, 因此這種作法目標在於有測試保護, 並且在未來重構時可以執行測試
- 依據設計需要重構成不同的架構, 但是可以享有先前撰寫的測試
- 值得參考書中的範例, 來看到設計的演變
- 善用 renaming, 小心違反 Liskov substitution principle, LSP, 盡可能依賴抽象

---

### 第九章 - 無法將類別放入測試控制工具之中

- 無法在測試工具中實體化類別, 所遇到的常見問題
- 有些解決方案, 都不是用於 production 環境, 只是因應測試需要而產生, 需要分清楚使用時機

9.1 令人惱火的參數

- 最直接的作法就是試一試, 因此建立一個建構測試, 測試中只包含建構並且不含有斷言, 此測試在未來可以被重構或刪除
- 在物件導向上使用界面提取 (Extract interface) 解構不想要的的呼叫
- 在測試上可以在建構子傳遞 `null` 探測, 實際需求. 在報錯的時候提供更好的 mock object.
- **在 production 不要傳遞 `null` 當成參數** 是壞的實務

9.2 隱藏依賴

- 針對藏在建構子裡的隱藏依賴, 可以藉由創建或改寫建構子成**參數化**. 把內部隱藏的依賴變成外部傳遞, 以利測試與解依賴
- 仍然可以保持原有的界面不變

9.3 構造塊

- 在建構子不容易參數化時, 可以在建構子建構完成後以替換的方式把不想要的內部物件替換掉
- 注意可能造成的資源管理問題, 例如 C++ 中替換時需要先 delete 原先的物件, 並且要注意解構子執行了什麼
- 實體替換技術不應該在 production 中被使用

9.4 惱人的全域依賴

- 依賴全域變數會導致建立物件很困難,
- 書中以物件導向中常見的 singleton pattern 作為全域變數使用為例, 並且藉由各種技術鬆綁限制, 以利測試
- 當系統中出現很多地方存取相同的全域變數時, 就代表分層設計沒有做好. 導致每個元件的權責不清

9.5 可怕的包含依賴

- 以 C++ 中必須標明的標頭檔 `.h` 為例子, 
- 順序為
  1. 先建立測試用的程式 (mock) 產生對的測試用程式標頭檔, 先使巨大的物件能被納入測試工具中
  1. 未來一步步重構把大物件分割成小物件, 並且擁有對應的測試, 
  1. 在完成之後大物件的測試程式就可以被移除了

9.6 洋蔥參數

- 當建構時需要傳遞其他已建構的物件時, 可能會產生一連串的建構行為 
- 一樣可以配合在測試時傳遞 `null`, 或界面抽取的方式, 解除依賴

9.7 化名參數

- 當界面抽取不容易實現時, 原因是回傳值與界面型別不同造成的麻煩
- 解決方法 1. 針對物件繼承鍊上每個物件都抽取成界面並且遵循繼承 (太麻煩)
- 解決方法 2. 詢問為什麼我們需要抽離依賴 (太慢? 有不想要的副作用?, ...) 然後在測試中以新的測試用子物件來 override 不想要的副作用函式

---

### 第十章 - 無法在測試控制工具中執行方法

- 當能夠把實體化納入測試工具之後, 就是要為想要測試的函式撰寫測試
- 在撰寫函式測試時可能遇到的問題
- 好的設計應該是可測試的

10.1 隱藏的方法

- 修改的是 private 方法時, 要測試只能放鬆限制或通過使用到的公開界面測試
- 可以藉由移動 private 方法至另外的類別中並以 public 方法存在其中, 在 private 的使用該物件

10.2 "有益的" 語言特性

- 遇到程式語言中權限限制的特性例如 `final`, `sealed` 等等, 產生難以測試的函式時.
- 這些限制的特性具有安全性的意義, 因此實際上使用時最好增加一層 Wrapper 進行底層封裝, 讓 Wrapper 以上是可以進行測試的
- 範例中以測試 C# 原生函式庫的 final class 為例, 提供解耦合的示範

10.3 無法探知的副作用

- 當物件內部又有額外的依賴, 因為權責不清導致無法感知影響, 從而無法進行測試. 
- 範例以一個混合了 command + query + UI 的函式為例, 示範如何重構解耦合
- 分離 UI 顯示與非 UI 顯示, 
- 讓相關的內容耦合在一起 (分組), 無關的分開 (分類), 更清楚的權責, 解開不必要的耦合
- 使用 command-query separation pattern, 讓有副作用與無副作用的函式分開

---

### 第十一章 - 修改時應當測試哪些方法

- 為遺留程式碼撰寫測試的位置
- 一個好的程式, 影響結構圖應該是清晰簡單的

11.1 推測程式碼修改所產生的影響

- 從比較小的基礎的元件開始可以藉由畫出影響圖, 來呈現可能變動的內容與影響範圍
- 移動到使用到該元件的內容中去探索, 是否會產生變動與影響範圍
- 與除錯相比, 除錯是由上而下的探索, 推測影響範圍與變動則是由下而上的探索

11.2 前向推測

- 藉由畫出影響圖, 找到可以感知變動的位置, 即可以撰寫測試的位置
- 在探索影響時, 需要考慮到所有的客戶端 (使用者), 與可能的子類別與父類別
- 測試執行時的探索範圍是由上往下的
- 影響即副作用 side-effect

11.3 影響的傳播

- 影響不一定是一眼能看出來的例如使用函式回傳值
- 還有其他隱藏的影響例如通過 reference 修改內容 (side-effect)
- 使用到全域變數
- 以上三種是三種基本途徑, 產生影響

11.4 進行影響推測的工具

- 通過每種程式語言提供的限制語法, 例如 `private`, `final` 等等, 來協助探索影響
- 對所用語言的了解與把握是十分必要的, 了解你所用的語言

11.5 從影響分析當中學習

- 藉由影響分析去學習程式語言的使用與模式
- 一個好的程式碼是不會有太多的陷阱 (gotcha), 會符合某些規則.
- 函數式程式語言 (Haskell, ...) 相對來說就是容易推理影響的, 因為 pure function 帶來的好處
- 為程式加上一些影響範圍的限制, 是讓測試容易撰寫的

11.6 簡化影響結構示意圖

- 藉由調整程式實作, 簡化影響結構圖, 越簡單的影響結構越容易撰寫測試
- 要確定撰寫測試的位置, 進行影響推測是為數不多的使用技能之一
- 影響, 測試與封裝, 好的封裝可以讓影響範圍簡化, 封裝本身的目的也是為了容易了解程式碼
  - 如果封裝破壞了影響範圍的理解容易性, 反而應該破壞封裝增加測試來探知影響, 再重構成好的封裝簡化影響範圍

---

### 第十二章 - 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴

- 當要修改的程式有很多相依, 並且不容易全部解依賴, 在撰寫測試時可以考慮撰寫整合測試, 在上一層共同的界面進行測試
- 高階界面測試無法取代單元測試, 而是為了協助重構奠定撰寫單元測試的基礎
- 尋找 interception point 與 pinch point 來撰寫整合測試

12.1 攔截點 (interception point)

- 一個位置被修改後能夠探知影響的位置都是攔截點, 但是不一定是最好的位置
- 一開始應該從確定要修改的位置開始向外探索影響, 尋找最佳的攔截點

12.1.1 簡單的情形

- 藉由畫出影響圖來找出所有的攔截點, 再來思考最佳的攔截點位置, 撰寫測試
- 由將要修改的位置出發, 一路畫出影響圖, 
- 判斷最佳攔截點的依據, 
  1. 要擁有存取權 (才能撰寫測試)
  1. 撰寫良好的整合測試, 要能檢查到足夠多的影響
  1. 修改點與最佳攔截點也不應離的太遠, 會導致測試難以撰寫, 並且安全性可能不足

---

### 第十三章 - 修改時應該怎樣寫測試

---

### 第十四章 - 棘手的函式庫依賴問題

---

### 第十五章 - 到處都是 API 呼叫

---

### 第十六章 - 對程式碼的理解不足

---

### 第十七章 - 程式毫無結構可言

---

### 第十八章 - 測試程式碼礙手礙腳

---

### 第十九章 - 對非物件導向的專案，如何安全地對它進行修改

---

### 第二十章 - 處理大類別

---

### 第二十一章 - 需要修改大量相同的程式碼

---

### 第二十二章 - 要修改一個巨型方法，卻沒辦法為它編寫測試

---

### 第二十三章 - 降低修改的風險

---

### 第二十四章 - 當你感到絕望時

---

Part III 解依賴技術

---

### 第二十五章 - 解依賴技術

---

### 第二十六章 - Appendix 重構

---

438