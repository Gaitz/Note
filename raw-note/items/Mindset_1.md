## Working Effectively with Legacy Code, Michael C. Feathers

### Working Effectively with Legacy Code, 中文版, ComputerScience/Mindset

---

Part I 修改機制

第一章 - 修改軟體

第二章 - 帶著回饋工作

第三章 - 感測與分離

第四章 - 接縫模型

第五章 - 工具

Part II 修改程式碼的技術

第六章 - 時間緊迫，但必須修改

第七章 - 漫長的修改

第八章 - 添加特性

第九章 - 無法將類別放入測試控制工具之中

第十章 - 無法在測試控制工具中執行方法

第十一章 - 修改時應當測試哪些方法

第十二章 - 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴

第十三章 - 修改時應該怎樣寫測試

第十四章 - 棘手的函式庫依賴問題

第十五章 - 到處都是 API 呼叫

第十六章 - 對程式碼的理解不足

第十七章 - 程式毫無結構可言

第十八章 - 測試程式碼礙手礙腳

第十九章 - 對非物件導向的專案，如何安全地對它進行修改

第二十章 - 處理大類別

第二十一章 - 需要修改大量相同的程式碼

第二十二章 - 要修改一個巨型方法，卻沒辦法為它編寫測試

第二十三章 - 降低修改的風險

第二十四章 - 當你感到絕望時

Part III 解依賴技術

第二十五章 - 解依賴技術

第二十六章 - Appendix 重構

---

Part I 修改機制

---

### 第一章 - 修改軟體

- 保持既有行為不變是軟體開發中最據挑戰性的任務之一
- 危險的修改, 修改程式是必定發生的, 壞的架構與好的架構, 取決於易讀性與讀完後對修改的信心程度
- 修改是需要時常練習的

---

### 第二章 - 帶著回饋工作

- Edit and Pray vs. Cover and Modify
- 把要修改的部份使用測試覆蓋 (Cover) 來驗證變動
- End-to-End Test 作用於 Application layer 執行速度太慢了, 不利於開發驗證
- 使用單元測試與重構, 清晰化要修改的邏輯並且有測試保護 (驗證變動與協助理解功能)

2.1 單元測試

- 單元測試, 測試最基本單位的元件, 例如函式 (function), 類別 (class)
- 測試的隔離性, 廣泛規模的大型測試 (整合測試 integration test), 有其價值但是也有些問題
  - 錯誤定位, 當錯誤發生時不容易找出錯誤發生點
  - 執行時間過長, 導致無法頻繁的執行
- 好的單元測試, 要具備執行速度快, 能協助定位錯誤發生點, (短小易理解, 協助錯誤定位)
- 為測試分類, 每種測試類型都有他的好處, 但是不能混用導致錯誤的使用時機
- 單元測試不應該
  - 與資料庫互動
  - 含有 Networking
  - 接觸檔案系統
  - 需要額外對環境設定

2.3 測試覆蓋

- 為遺留程式碼進行修改時添加測試的方法
- 為了針對將要修改的內容添加測試, 有可能會需要一般小心的做重構 (去耦合) 讓測試容易撰寫
- 策略 1. 加入界面隔離 (Extract Interface)
- 策略 2. 添加精簡的傳入值, (Primitive Parameter)
- 程式可能變醜, 但是更容易測試更安全, 在未來再進行重構

2.4 遺留程式碼修改演算法

- 修改遺留程式碼的流程
1. 確定變動點
   - 閱讀程式碼, 增加理解程度找出正確的修改地點
1. 找出測試點
   - 針對變動點找出編寫測試的位置
1. 解依賴
   - 為了容易在測試中實例化 (instance)
   - 容易執行要測試的函式
1. 編寫測試
1. 實際修改與重構
   - 推薦使用 Test-driven development (TDD) 來添加新功能

---

### 第三章 - 感測與分離

- **利用測試感測程式的影響範圍與效用**
- 為了測試所需要解耦合的兩個原因
  - 感測, 無法取得回傳值時 (無法測試驗證)
  - 分離, 無法把一部分程式碼納入測試中時 (無法撰寫單元測試)

3.1 偽裝成合作者 (mocking)

- 建立 fake object, fake function 來 mocking, 實現**分離**來撰寫單元測試
- 為了建立 fake collaborators 需要進行重構, 利用界面分離, 分割成子函式等方式
- fake collaborators 上可以擴充界面新增一些回傳值, 函式來協助測試， 達到**感測**  
- 應該要撰寫簡單, 並且能有效測試

---

### 第四章 - 接縫模型

- 可測試的程式碼
- 越熟練實作可測試的程式碼, 會對於好的程式架構有不同的看法
- 接縫 (seam) 是在不改變函式呼叫的情況下, 改變被呼叫的函式. 通常由引入中間層達成。用來作為解耦合的技巧
- 每個接縫 (seam) 都會有一個開關 (enabling point) 用來決定執行的行為 
- 試著思考接縫位置與其開關, 並且確保開關在 production 與 test 中是明顯可見的. 
- 使用接縫的目的在於盡少的修改遺留程式碼, 但是提供良好測試的機會

4.3 接縫類型

- 依據不同的程式語言類型, 尋找不同的接縫達成方式
- 預處理期接縫, 在編譯期之前的處理.
  - 例如 C/C++ 中的巨集處理, 可以用來實現接縫
- 連接期接縫, 在讀取函式庫時的連結, 轉換
  - 例如 Java 中以不同的 `classpath`  指定使用的函式庫
- 物件接縫, 存在於大多數的物件導向程式語言中

---

### 第五章 - 工具

5.1 自動化重構工具

- 在使用自動化重構工具前, 最好先進行測試, 確保重構工具能安全的重構
- 即使有自動化重構工具, 仍最好先擁有測試保護

5.2 Mock object

- 解依賴, 在測試時提供仿造的物件 (mock object)

5.3 單元測試控制工具

- xUnit 系列

5.4 一般測試控制工具

- 執行整合測試的工具
- 例如 FIT, Fitnesse

---

Part II 修改程式碼的技術

---

### 第六章 - 時間緊迫，但必須修改

- 修改前優先投資於測試

6.1 新生方法 (Sprout Method)

- 如果要添加的特性, 是可以使用全新的程式碼達成時, 建議直接建立新的方法, 然後引入.
- 新生方法更容易添加測試, 並且可以良好的分離不同的操作
- 撰寫程式碼時要一同思考是否清晰, 分離不同的邏輯
- 任何時候如果能使用新生方法 (新功能可以以獨立的程式碼實作) 時,  推薦優先使用

---

### 第七章 - 漫長的修改

---

### 第八章 - 添加特性

---

### 第九章 - 無法將類別放入測試控制工具之中

---

### 第十章 - 無法在測試控制工具中執行方法

---

### 第十一章 - 修改時應當測試哪些方法

---

### 第十二章 - 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴

---

### 第十三章 - 修改時應該怎樣寫測試

---

### 第十四章 - 棘手的函式庫依賴問題

---

### 第十五章 - 到處都是 API 呼叫

---

### 第十六章 - 對程式碼的理解不足

---

### 第十七章 - 程式毫無結構可言

---

### 第十八章 - 測試程式碼礙手礙腳

---

### 第十九章 - 對非物件導向的專案，如何安全地對它進行修改

---

### 第二十章 - 處理大類別

---

### 第二十一章 - 需要修改大量相同的程式碼

---

### 第二十二章 - 要修改一個巨型方法，卻沒辦法為它編寫測試

---

### 第二十三章 - 降低修改的風險

---

### 第二十四章 - 當你感到絕望時

---

Part III 解依賴技術

---

### 第二十五章 - 解依賴技術

---

### 第二十六章 - Appendix 重構

---

438