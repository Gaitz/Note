## Working Effectively with Legacy Code, Michael C. Feathers

### Working Effectively with Legacy Code, 中文版, ComputerScience/Mindset

---

Part I 修改機制

第一章 - 修改軟體

第二章 - 帶著回饋工作

第三章 - 感測與分離

第四章 - 接縫模型

第五章 - 工具

Part II 修改程式碼的技術

第六章 - 時間緊迫，但必須修改

第七章 - 漫長的修改

第八章 - 添加特性

第九章 - 無法將類別放入測試控制工具之中

第十章 - 無法在測試控制工具中執行方法

第十一章 - 修改時應當測試哪些方法

第十二章 - 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴

第十三章 - 修改時應該怎樣寫測試

第十四章 - 棘手的函式庫依賴問題

第十五章 - 到處都是 API 呼叫

第十六章 - 對程式碼的理解不足

第十七章 - 程式毫無結構可言

第十八章 - 測試程式碼礙手礙腳

第十九章 - 對非物件導向的專案，如何安全地對它進行修改

第二十章 - 處理大類別

第二十一章 - 需要修改大量相同的程式碼

第二十二章 - 要修改一個巨型方法，卻沒辦法為它編寫測試

第二十三章 - 降低修改的風險

第二十四章 - 當你感到絕望時

Part III 解依賴技術

第二十五章 - 解依賴技術

第二十六章 - Appendix 重構

---

Part I 修改機制

---

### 第一章 - 修改軟體

- 保持既有行為不變是軟體開發中最據挑戰性的任務之一
- 危險的修改, 修改程式是必定發生的, 壞的架構與好的架構, 取決於易讀性與讀完後對修改的信心程度
- 修改是需要時常練習的

---

### 第二章 - 帶著回饋工作

- Edit and Pray vs. Cover and Modify
- 把要修改的部份使用測試覆蓋 (Cover) 來驗證變動
- End-to-End Test 作用於 Application layer 執行速度太慢了, 不利於開發驗證
- 使用單元測試與重構, 清晰化要修改的邏輯並且有測試保護 (驗證變動與協助理解功能)

2.1 單元測試

- 單元測試, 測試最基本單位的元件, 例如函式 (function), 類別 (class)
- 測試的隔離性, 廣泛規模的大型測試 (整合測試 integration test), 有其價值但是也有些問題
  - 錯誤定位, 當錯誤發生時不容易找出錯誤發生點
  - 執行時間過長, 導致無法頻繁的執行
- 好的單元測試, 要具備執行速度快, 能協助定位錯誤發生點, (短小易理解, 協助錯誤定位)
- 為測試分類, 每種測試類型都有他的好處, 但是不能混用導致錯誤的使用時機
- 單元測試不應該
  - 與資料庫互動
  - 含有 Networking
  - 接觸檔案系統
  - 需要額外對環境設定

2.3 測試覆蓋

- 為遺留程式碼進行修改時添加測試的方法
- 為了針對將要修改的內容添加測試, 有可能會需要一般小心的做重構 (去耦合) 讓測試容易撰寫
- 策略 1. 加入界面隔離 (Extract Interface)
- 策略 2. 添加精簡的傳入值, (Primitive Parameter)
- 程式可能變醜, 但是更容易測試更安全, 在未來再進行重構

2.4 遺留程式碼修改演算法

- 修改遺留程式碼的流程
1. 確定變動點
   - 閱讀程式碼, 增加理解程度找出正確的修改地點
1. 找出測試點
   - 針對變動點找出編寫測試的位置
1. 解依賴
   - 為了容易在測試中實例化 (instance)
   - 容易執行要測試的函式
1. 編寫測試
1. 實際修改與重構
   - 推薦使用 Test-driven development (TDD) 來添加新功能

---

### 第三章 - 感測與分離

- **利用測試感測程式的影響範圍與效用**
- 為了測試所需要解耦合的兩個原因
  - 感測, 無法取得回傳值時 (無法測試驗證)
  - 分離, 無法把一部分程式碼納入測試中時 (無法撰寫單元測試)

3.1 偽裝成合作者 (mocking)

- 建立 fake object, fake function 來 mocking, 實現**分離**來撰寫單元測試
- 為了建立 fake collaborators 需要進行重構, 利用界面分離, 分割成子函式等方式
- fake collaborators 上可以擴充界面新增一些回傳值, 函式來協助測試， 達到**感測**  
- 應該要撰寫簡單, 並且能有效測試

---

### 第四章 - 接縫模型

- 可測試的程式碼
- 越熟練實作可測試的程式碼, 會對於好的程式架構有不同的看法
- 接縫 (seam) 是在不改變函式呼叫的情況下, 改變被呼叫的函式. 通常由引入中間層達成。用來作為解耦合的技巧
- 每個接縫 (seam) 都會有一個開關 (enabling point) 用來決定執行的行為 
- 試著思考接縫位置與其開關, 並且確保開關在 production 與 test 中是明顯可見的. 
- 使用接縫的目的在於盡少的修改遺留程式碼, 但是提供良好測試的機會

4.3 接縫類型

- 依據不同的程式語言類型, 尋找不同的接縫達成方式
- 預處理期接縫, 在編譯期之前的處理.
  - 例如 C/C++ 中的巨集處理, 可以用來實現接縫
- 連接期接縫, 在讀取函式庫時的連結, 轉換
  - 例如 Java 中以不同的 `classpath`  指定使用的函式庫
- 物件接縫, 存在於大多數的物件導向程式語言中

---

### 第五章 - 工具

5.1 自動化重構工具

- 在使用自動化重構工具前, 最好先進行測試, 確保重構工具能安全的重構
- 即使有自動化重構工具, 仍最好先擁有測試保護

5.2 Mock object

- 解依賴, 在測試時提供仿造的物件 (mock object)

5.3 單元測試控制工具

- xUnit 系列

5.4 一般測試控制工具

- 執行整合測試的工具
- 例如 FIT, Fitnesse

---

Part II 修改程式碼的技術

---

### 第六章 - 時間緊迫，但必須修改

- 修改前優先投資於測試
- 各種作法的重點都在於現有的架構無法納入測試, 但是新功能開發需使用測試保護.
- 從新功能一步一步的改進, 在熟悉舊架構的同時未來也有能力幫其撰寫測試

6.1 新生方法 (Sprout Method)

- 如果要添加的特性, 是可以使用全新的程式碼達成時, 建議直接建立新的方法, 然後引入.
- 新生方法更容易添加測試, 並且可以良好的分離不同的操作
- 撰寫程式碼時要一同思考是否清晰, 分離不同的邏輯
- 任何時候如果能使用新生方法 (新功能可以以獨立的程式碼實作) 時,  推薦優先使用

6.2 新生類別 (Sprout Class)

- 在新生方法無法實現時, 即新生方法必須能納入測試.
- 在舊的類別無法為了新生方法納入測試環境時, 為了新功能建立一個新的物件來達成可測試的新方法.
- 需要審視且建立好的新物件名稱與格式

6.3 外覆方法 (Wrap Method)

- 在一個方法裡添加新的程式碼, 通常是可疑的 (可能不符合單一責任原則). 
- 在擴充函式時, 可以把舊有的實作封裝成另外的函式, **保持原函式界面**, 但是呼叫舊的實作與新的實作函式
- 缺點在於函式命名可能不精確, 與安全的抽離舊有實作

6.4 外覆類別 (Wrap Class)

- 外覆方法的物件版, 即裝飾模式 (decorator pattern)
- 或者使用非裝飾性的外覆類別, 但是變成在呼叫時需要換成新物件的名稱, 仍然保持界面

---

### 第七章 - 漫長的修改

7.1 理解程式碼

- 維護良好與遺留系統中的差別在於程式碼理解的容易程度
- 沒辦法理解程式碼就沒辦法定位要修改的位置與影響程度

7.2 時滯 (lag time)

- 修改到反饋的時間
- 在解依賴後配合 TDD 可以達到順暢的反饋時間

7.3 解依賴 (decouple)

- 在物件導向中首先要能在測試工具中實體化類別, 然後測試個別的方法
- 建構依賴, 為了加速反饋時間 (編譯到執行的時間), 要歸屬依賴形成更小的單元 (package 或函式庫), 在檔案結構上也會跟著變化, 更清晰與迅速
- 使用界面隔離分離依賴實作
- 依賴反轉原則, 
  - 程式碼依賴的對象越少變化越好, 因此界面是比實作更適合依賴的方式

---

### 第八章 - 添加特性

- 把舊有程式納入測試保護才是系統最堅固的基石

8.1 測試驅動開發 (Test-driven development, TDD)

- 紅燈 -> 綠燈 -> 重構 loop
- Baby step

8.2 差異式程式設計 (Programming by difference)

- 在物件導向中使用繼承, 以子物件 override 的方式實現新功能並且保有測試
- 但是繼承在物件導向中是不可被濫用的, 因此這種作法目標在於有測試保護, 並且在未來重構時可以執行測試
- 依據設計需要重構成不同的架構, 但是可以享有先前撰寫的測試
- 值得參考書中的範例, 來看到設計的演變
- 善用 renaming, 小心違反 Liskov substitution principle, LSP, 盡可能依賴抽象

---

### 第九章 - 無法將類別放入測試控制工具之中

- 無法在測試工具中實體化類別, 所遇到的常見問題

9.1 令人惱火的參數

- 最直接的作法就是試一試, 因此建立一個建構測試, 測試中只包含建構並且不含有斷言, 此測試在未來可以被重構或刪除

---

### 第十章 - 無法在測試控制工具中執行方法

---

### 第十一章 - 修改時應當測試哪些方法

---

### 第十二章 - 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴

---

### 第十三章 - 修改時應該怎樣寫測試

---

### 第十四章 - 棘手的函式庫依賴問題

---

### 第十五章 - 到處都是 API 呼叫

---

### 第十六章 - 對程式碼的理解不足

---

### 第十七章 - 程式毫無結構可言

---

### 第十八章 - 測試程式碼礙手礙腳

---

### 第十九章 - 對非物件導向的專案，如何安全地對它進行修改

---

### 第二十章 - 處理大類別

---

### 第二十一章 - 需要修改大量相同的程式碼

---

### 第二十二章 - 要修改一個巨型方法，卻沒辦法為它編寫測試

---

### 第二十三章 - 降低修改的風險

---

### 第二十四章 - 當你感到絕望時

---

Part III 解依賴技術

---

### 第二十五章 - 解依賴技術

---

### 第二十六章 - Appendix 重構

---

438