## Working Effectively with Legacy Code, Michael C. Feathers

### Working Effectively with Legacy Code, 中文版, ComputerScience/Mindset

---

Part I 修改機制

第一章 - 修改軟體

第二章 - 帶著回饋工作

第三章 - 感測與分離

第四章 - 接縫模型

第五章 - 工具

Part II 修改程式碼的技術

第六章 - 時間緊迫，但必須修改

第七章 - 漫長的修改

第八章 - 添加特性

第九章 - 無法將類別放入測試控制工具之中

第十章 - 無法在測試控制工具中執行方法

第十一章 - 修改時應當測試哪些方法

第十二章 - 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴

第十三章 - 修改時應該怎樣寫測試

第十四章 - 棘手的函式庫依賴問題

第十五章 - 到處都是 API 呼叫

第十六章 - 對程式碼的理解不足

第十七章 - 程式毫無結構可言

第十八章 - 測試程式碼礙手礙腳

第十九章 - 對非物件導向的專案，如何安全地對它進行修改

第二十章 - 處理大類別

第二十一章 - 需要修改大量相同的程式碼

第二十二章 - 要修改一個巨型方法，卻沒辦法為它編寫測試

第二十三章 - 降低修改的風險

第二十四章 - 當你感到絕望時

Part III 解依賴技術

第二十五章 - 解依賴技術

第二十六章 - Appendix 重構

---

Part I 修改機制

---

### 第一章 - 修改軟體

- 保持既有行為不變是軟體開發中最據挑戰性的任務之一
- 危險的修改, 修改程式是必定發生的, 壞的架構與好的架構, 取決於易讀性與讀完後對修改的信心程度
- 修改是需要時常練習的

---

### 第二章 - 帶著回饋工作

- Edit and Pray vs. Cover and Modify
- 把要修改的部份使用測試覆蓋 (Cover) 來驗證變動
- End-to-End Test 作用於 Application layer 執行速度太慢了, 不利於開發驗證
- 使用單元測試與重構, 清晰化要修改的邏輯並且有測試保護 (驗證變動與協助理解功能)

2.1 單元測試

- 單元測試, 測試最基本單位的元件, 例如函式 (function), 類別 (class)
- 測試的隔離性, 廣泛規模的大型測試 (整合測試 integration test), 有其價值但是也有些問題
  - 錯誤定位, 當錯誤發生時不容易找出錯誤發生點
  - 執行時間過長, 導致無法頻繁的執行
- 好的單元測試, 要具備執行速度快, 能協助定位錯誤發生點, (短小易理解, 協助錯誤定位)
- 為測試分類, 每種測試類型都有他的好處, 但是不能混用導致錯誤的使用時機
- 單元測試不應該
  - 與資料庫互動
  - 含有 Networking
  - 接觸檔案系統
  - 需要額外對環境設定

2.3 測試覆蓋

- 為遺留程式碼進行修改時添加測試的方法
- 為了針對將要修改的內容添加測試, 有可能會需要一般小心的做重構 (去耦合) 讓測試容易撰寫
- 策略 1. 加入界面隔離 (Extract Interface)
- 策略 2. 添加精簡的傳入值, (Primitive Parameter)
- 程式可能變醜, 但是更容易測試更安全, 在未來再進行重構

2.4 遺留程式碼修改演算法

- 修改遺留程式碼的流程
1. 確定變動點
   - 閱讀程式碼, 增加理解程度找出正確的修改地點
1. 找出測試點
   - 針對變動點找出編寫測試的位置
1. 解依賴
   - 為了容易在測試中實例化 (instance)
   - 容易執行要測試的函式
1. 編寫測試
1. 實際修改與重構
   - 推薦使用 Test-driven development (TDD) 來添加新功能

---

### 第三章 - 感測與分離

- **利用測試感測程式的影響範圍與效用**
- 為了測試所需要解耦合的兩個原因
  - 感測, 無法取得回傳值時 (無法測試驗證)
  - 分離, 無法把一部分程式碼納入測試中時 (無法撰寫單元測試)

3.1 偽裝成合作者 (mocking)

- 建立 fake object, fake function 來 mocking, 實現**分離**來撰寫單元測試
- 為了建立 fake collaborators 需要進行重構, 利用界面分離, 分割成子函式等方式
- fake collaborators 上可以擴充界面新增一些回傳值, 函式來協助測試， 達到**感測**  
- 應該要撰寫簡單, 並且能有效測試

---

### 第四章 - 接縫模型

- 可測試的程式碼
- 越熟練實作可測試的程式碼, 會對於好的程式架構有不同的看法
- 接縫 (seam) 是在不改變函式呼叫的情況下, 改變被呼叫的函式. 通常由引入中間層達成。用來作為解耦合的技巧
- 每個接縫 (seam) 都會有一個開關 (enabling point) 用來決定執行的行為 
- 試著思考接縫位置與其開關, 並且確保開關在 production 與 test 中是明顯可見的. 
- 使用接縫的目的在於盡少的修改遺留程式碼, 但是提供良好測試的機會

4.3 接縫類型

- 依據不同的程式語言類型, 尋找不同的接縫達成方式
- 預處理期接縫, 在編譯期之前的處理.
  - 例如 C/C++ 中的巨集處理, 可以用來實現接縫
- 連接期接縫, 在讀取函式庫時的連結, 轉換
  - 例如 Java 中以不同的 `classpath`  指定使用的函式庫
- 物件接縫, 存在於大多數的物件導向程式語言中

---

### 第五章 - 工具

5.1 自動化重構工具

- 在使用自動化重構工具前, 最好先進行測試, 確保重構工具能安全的重構
- 即使有自動化重構工具, 仍最好先擁有測試保護

5.2 Mock object

- 解依賴, 在測試時提供仿造的物件 (mock object)

5.3 單元測試控制工具

- xUnit 系列

5.4 一般測試控制工具

- 執行整合測試的工具
- 例如 FIT, Fitnesse

---

Part II 修改程式碼的技術

---

### 第六章 - 時間緊迫，但必須修改

- 修改前優先投資於測試
- 各種作法的重點都在於現有的架構無法納入測試, 但是新功能開發需使用測試保護.
- 從新功能一步一步的改進, 在熟悉舊架構的同時未來也有能力幫其撰寫測試

6.1 新生方法 (Sprout Method)

- 如果要添加的特性, 是可以使用全新的程式碼達成時, 建議直接建立新的方法, 然後引入.
- 新生方法更容易添加測試, 並且可以良好的分離不同的操作
- 撰寫程式碼時要一同思考是否清晰, 分離不同的邏輯
- 任何時候如果能使用新生方法 (新功能可以以獨立的程式碼實作) 時,  推薦優先使用

6.2 新生類別 (Sprout Class)

- 在新生方法無法實現時, 即新生方法必須能納入測試.
- 在舊的類別無法為了新生方法納入測試環境時, 為了新功能建立一個新的物件來達成可測試的新方法.
- 需要審視且建立好的新物件名稱與格式

6.3 外覆方法 (Wrap Method)

- 在一個方法裡添加新的程式碼, 通常是可疑的 (可能不符合單一責任原則). 
- 在擴充函式時, 可以把舊有的實作封裝成另外的函式, **保持原函式界面**, 但是呼叫舊的實作與新的實作函式
- 缺點在於函式命名可能不精確, 與安全的抽離舊有實作

6.4 外覆類別 (Wrap Class)

- 外覆方法的物件版, 即裝飾模式 (decorator pattern)
- 或者使用非裝飾性的外覆類別, 但是變成在呼叫時需要換成新物件的名稱, 仍然保持界面

---

### 第七章 - 漫長的修改

7.1 理解程式碼

- 維護良好與遺留系統中的差別在於程式碼理解的容易程度
- 沒辦法理解程式碼就沒辦法定位要修改的位置與影響程度

7.2 時滯 (lag time)

- 修改到反饋的時間
- 在解依賴後配合 TDD 可以達到順暢的反饋時間

7.3 解依賴 (decouple)

- 在物件導向中首先要能在測試工具中實體化類別, 然後測試個別的方法
- 建構依賴, 為了加速反饋時間 (編譯到執行的時間), 要歸屬依賴形成更小的單元 (package 或函式庫), 在檔案結構上也會跟著變化, 更清晰與迅速
- 使用界面隔離分離依賴實作
- 依賴反轉原則, 
  - 程式碼依賴的對象越少變化越好, 因此界面是比實作更適合依賴的方式

---

### 第八章 - 添加特性

- 把舊有程式納入測試保護才是系統最堅固的基石

8.1 測試驅動開發 (Test-driven development, TDD)

- 紅燈 -> 綠燈 -> 重構 loop
- Baby step

8.2 差異式程式設計 (Programming by difference)

- 在物件導向中使用繼承, 以子物件 override 的方式實現新功能並且保有測試
- 但是繼承在物件導向中是不可被濫用的, 因此這種作法目標在於有測試保護, 並且在未來重構時可以執行測試
- 依據設計需要重構成不同的架構, 但是可以享有先前撰寫的測試
- 值得參考書中的範例, 來看到設計的演變
- 善用 renaming, 小心違反 Liskov substitution principle, LSP, 盡可能依賴抽象

---

### 第九章 - 無法將類別放入測試控制工具之中

- 無法在測試工具中實體化類別, 所遇到的常見問題
- 有些解決方案, 都不是用於 production 環境, 只是因應測試需要而產生, 需要分清楚使用時機

9.1 令人惱火的參數

- 最直接的作法就是試一試, 因此建立一個建構測試, 測試中只包含建構並且不含有斷言, 此測試在未來可以被重構或刪除
- 在物件導向上使用界面提取 (Extract interface) 解構不想要的的呼叫
- 在測試上可以在建構子傳遞 `null` 探測, 實際需求. 在報錯的時候提供更好的 mock object.
- **在 production 不要傳遞 `null` 當成參數** 是壞的實務

9.2 隱藏依賴

- 針對藏在建構子裡的隱藏依賴, 可以藉由創建或改寫建構子成**參數化**. 把內部隱藏的依賴變成外部傳遞, 以利測試與解依賴
- 仍然可以保持原有的界面不變

9.3 構造塊

- 在建構子不容易參數化時, 可以在建構子建構完成後以替換的方式把不想要的內部物件替換掉
- 注意可能造成的資源管理問題, 例如 C++ 中替換時需要先 delete 原先的物件, 並且要注意解構子執行了什麼
- 實體替換技術不應該在 production 中被使用

9.4 惱人的全域依賴

- 依賴全域變數會導致建立物件很困難,
- 書中以物件導向中常見的 singleton pattern 作為全域變數使用為例, 並且藉由各種技術鬆綁限制, 以利測試
- 當系統中出現很多地方存取相同的全域變數時, 就代表分層設計沒有做好. 導致每個元件的權責不清

9.5 可怕的包含依賴

- 以 C++ 中必須標明的標頭檔 `.h` 為例子, 
- 順序為
  1. 先建立測試用的程式 (mock) 產生對的測試用程式標頭檔, 先使巨大的物件能被納入測試工具中
  1. 未來一步步重構把大物件分割成小物件, 並且擁有對應的測試, 
  1. 在完成之後大物件的測試程式就可以被移除了

9.6 洋蔥參數

- 當建構時需要傳遞其他已建構的物件時, 可能會產生一連串的建構行為 
- 一樣可以配合在測試時傳遞 `null`, 或界面抽取的方式, 解除依賴

9.7 化名參數

- 當界面抽取不容易實現時, 原因是回傳值與界面型別不同造成的麻煩
- 解決方法 1. 針對物件繼承鍊上每個物件都抽取成界面並且遵循繼承 (太麻煩)
- 解決方法 2. 詢問為什麼我們需要抽離依賴 (太慢? 有不想要的副作用?, ...) 然後在測試中以新的測試用子物件來 override 不想要的副作用函式

---

### 第十章 - 無法在測試控制工具中執行方法

- 當能夠把實體化納入測試工具之後, 就是要為想要測試的函式撰寫測試
- 在撰寫函式測試時可能遇到的問題
- 好的設計應該是可測試的

10.1 隱藏的方法

- 修改的是 private 方法時, 要測試只能放鬆限制或通過使用到的公開界面測試
- 可以藉由移動 private 方法至另外的類別中並以 public 方法存在其中, 在 private 的使用該物件

10.2 "有益的" 語言特性

- 遇到程式語言中權限限制的特性例如 `final`, `sealed` 等等, 產生難以測試的函式時.
- 這些限制的特性具有安全性的意義, 因此實際上使用時最好增加一層 Wrapper 進行底層封裝, 讓 Wrapper 以上是可以進行測試的
- 範例中以測試 C# 原生函式庫的 final class 為例, 提供解耦合的示範

10.3 無法探知的副作用

- 當物件內部又有額外的依賴, 因為權責不清導致無法感知影響, 從而無法進行測試. 
- 範例以一個混合了 command + query + UI 的函式為例, 示範如何重構解耦合
- 分離 UI 顯示與非 UI 顯示, 
- 讓相關的內容耦合在一起 (分組), 無關的分開 (分類), 更清楚的權責, 解開不必要的耦合
- 使用 command-query separation pattern, 讓有副作用與無副作用的函式分開

---

### 第十一章 - 修改時應當測試哪些方法

- 為遺留程式碼撰寫測試的位置
- 一個好的程式, 影響結構圖應該是清晰簡單的

11.1 推測程式碼修改所產生的影響

- 從比較小的基礎的元件開始可以藉由畫出影響圖, 來呈現可能變動的內容與影響範圍
- 移動到使用到該元件的內容中去探索, 是否會產生變動與影響範圍
- 與除錯相比, 除錯是由上而下的探索, 推測影響範圍與變動則是由下而上的探索

11.2 前向推測

- 藉由畫出影響圖, 找到可以感知變動的位置, 即可以撰寫測試的位置
- 在探索影響時, 需要考慮到所有的客戶端 (使用者), 與可能的子類別與父類別
- 測試執行時的探索範圍是由上往下的
- 影響即副作用 side-effect

11.3 影響的傳播

- 影響不一定是一眼能看出來的例如使用函式回傳值
- 還有其他隱藏的影響例如通過 reference 修改內容 (side-effect)
- 使用到全域變數
- 以上三種是三種基本途徑, 產生影響

11.4 進行影響推測的工具

- 通過每種程式語言提供的限制語法, 例如 `private`, `final` 等等, 來協助探索影響
- 對所用語言的了解與把握是十分必要的, 了解你所用的語言

11.5 從影響分析當中學習

- 藉由影響分析去學習程式語言的使用與模式
- 一個好的程式碼是不會有太多的陷阱 (gotcha), 會符合某些規則.
- 函數式程式語言 (Haskell, ...) 相對來說就是容易推理影響的, 因為 pure function 帶來的好處
- 為程式加上一些影響範圍的限制, 是讓測試容易撰寫的

11.6 簡化影響結構示意圖

- 藉由調整程式實作, 簡化影響結構圖, 越簡單的影響結構越容易撰寫測試
- 要確定撰寫測試的位置, 進行影響推測是為數不多的使用技能之一
- 影響, 測試與封裝, 好的封裝可以讓影響範圍簡化, 封裝本身的目的也是為了容易了解程式碼
  - 如果封裝破壞了影響範圍的理解容易性, 反而應該破壞封裝增加測試來探知影響, 再重構成好的封裝簡化影響範圍

---

### 第十二章 - 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴

- 當要修改的程式有很多相依, 並且不容易全部解依賴, 在撰寫測試時可以考慮撰寫整合測試, 在上一層共同的界面進行測試
- 高階界面測試無法取代單元測試, 而是為了協助重構奠定撰寫單元測試的基礎
- 尋找 interception point 與 pinch point 來撰寫整合測試

12.1 攔截點 (interception point)

- 一個位置被修改後能夠探知影響的位置都是攔截點, 但是不一定是最好的位置
- 一開始應該從確定要修改的位置開始向外探索影響, 尋找最佳的攔截點

12.1.1 簡單的情形

- 藉由畫出影響圖來找出所有的攔截點, 再來思考最佳的攔截點位置, 撰寫測試
- 由將要修改的位置出發, 一路畫出影響圖, 
- 判斷最佳攔截點的依據, 
  1. 要擁有存取權 (才能撰寫測試)
  1. 撰寫良好的整合測試, 要能檢查到足夠多的影響
  1. 修改點與最佳攔截點也不應離的太遠, 會導致測試難以撰寫, 並且安全性可能不足

---

### 第十三章 - 修改時應該怎樣寫測試

- 測試的目標專注於協助撰寫正確的程式碼, 盡可能避免 bug 進入, 而非企圖捕捉所有的 bug

13.1 特徵測試 (characterization test)

- 用於保持行為的測試
- 撰寫流程為
  1. 引用想要測試的程式區塊
  1. 撰寫會失敗的斷言
  1. 從失敗的斷言中來研究程式區塊實際的行為
  1. 修改斷言來符合程式區塊的當前行為
- 這種測試可能包含原本就是錯誤的行為, 但是沒關係, 重點在於保護未來的修改不會影響當前的行為
- 並且協助了解遺留程式碼的行為, 協助理解與溝通
- 在準備使用遺留程式碼中的程式前最好先撰寫特徵測試, 來協助理解與溝通

13.2 刻畫類別

- 利用測試去探測遺留程式碼
- 針對邏輯複雜的地方
- 針對猜想中可能有誤的情況
- 針對極端的輸入值
- 如果發現 bug 的話, 依據情況, 最好能提早修正

13.3 目標測試

- 測試要涵蓋準備修改的內容的所有分支, 或者說需要針對個別分支去撰寫測試

13.4 編寫特徵測試的啟發式方法

1. 先以測試來檢查準備修改的遺留程式碼區塊, 直到對當前的行為足夠了解
1. 為修改後的新內容撰寫測試
1. 如果需要重構, 則為重構的地方撰寫測試, 確保測試覆蓋所有新編寫的程式碼 (重構 + 新功能)

---

### 第十四章 - 棘手的函式庫依賴問題

- 濫用函式庫依賴產生的問題
- 避免直接呼叫函式庫, 必須要用界面隔離, 以便在未來能夠脫離與調整
- 好的函式庫除了在 production 環境運作良好, 還必須要能夠方便撰寫測試
- 時常遇到的問題是藉由個別語言特性的限制語法導致測試難以撰寫
- 可以考慮定義程式撰寫慣例取代語言限制語法

---

### 第十五章 - 到處都是 API 呼叫

- 遺留程式碼到處都是 API 呼叫的程式碼比全部自己撰寫的程式碼更困難處理
- 要提出更好的設計來清晰化遺留程式碼
- 技術上
  - 使用 Skin and Wrap the API  來做到介面隔離所有的第三方函式庫呼叫
  - 使用 Responsibility-Based Extraction 權責分離成更好的設計, 但是仍然直接呼叫 API

---

### 第十六章 - 對程式碼的理解不足

- 協助理解遺留程式碼的工具們

16.1 註記 / 草圖

- 如果單純閱讀程式碼無法理解清楚時, 可以劃一些草圖並且註記來協助理解
- 不需要是正式的流程圖或者 UML

16.2 清單標註

- 依據想要理解或處理的事情, 使用清單標註
- 分組, 標註, ...

16.3 草稿式重構

- 重構是認識程式碼最佳的技術, 藉由抽取, 搬動, 重新命名等等方式, 協助理解程式碼
- 真實的重構需要測試保護才能避免破壞行為
- 通過版本控制, 可以任意重構, 不管是否錯誤, 目的只是要更容易理解程式碼
- 缺點是對草稿式重構的定錨, 草稿式重構的內容可能不是最佳結構或作法. 

16.4 刪除不用的程式碼

- 刪除廢碼 !
- 如果真的需要仍然可以從版本控制系統中取得過去的程式碼

---

### 第十七章 - 程式毫無結構可言

- 處理一個複雜的程式庫, 過於複雜以至於沒有人全盤的了解
- 書中提出一些, 協助理解複雜程式庫的技術

17.1 講解系統的故事

- 需兩個人配合, 一個負責說, 一個負責聽
- 以簡短的句子簡潔的闡述系統中最重要的概念
- 然後在依序的講解下一層級的概念
- 利用最簡潔的方式闡述系統, 來思考架構的權責與新功能應該如何加入

17.2 Naked CRC

- 一群人討論時
- CRC, Class, Responsibility, Collaboration
- 使用實體卡片與肢體動作描述, 系統運作
- 卡片代表 instance 而非 class
- 相疊在一起的卡片代表一組 instances

17.3 反省你們的交流或討論

- 除了時常討論系統之外, 也要反思程式的實際設計是否跟討論的系統一致
- 盡可能得讓程式設計成與討論的系統一致, 並且易於理解

---

### 第十八章 - 測試程式碼礙手礙腳

- 為測試程式加上約束

18.1 類別命名約定

- 為程式與測試程式以特定的命名約束
- 例如使用 `Test` 作為測試程式的前輟或後輟
- 針對其他測試使用的元件例如 mock 使用 `Fake`, 或者 `Testing` 作為前輟或後輟

18.2 測試程式碼放在哪裡

- 推薦把測試程式與實際程式放在相同的地方, 易於瀏覽
- 針對建置或部屬 production 時, 可以在依據命名約定而過濾掉, 避開容量問題

---

### 第十九章 - 對非物件導向的專案，如何安全地對它進行修改

- 針對除了物件導向之外的程式語言, 為了安全的修改進行測試
- 以程序式程式語言為例 (`C`)
- 針對 C 語言可以使用巨集語法來協助製作 mock 與測試的引入

19.3 添加新行為

- 寧可引入新的函式, 也不要新增程式碼在舊有的程式碼中
- 使用 TDD 
- 針對 C 語言可以使用`函數指標`語法, 來決定測試或實際執行時的函式

19.4 利用物件導向的優勢

- 目前很多程序式程式語言, 可以延伸支援物件導向模式
- 因此可以慢慢的往物件導向模式去進行解耦合, 以利測試
- 書中範例以 C 程式語言往 C++ 物件導向模式移植並且解耦合
- 程序式程式語言, 也是一種物件導向程式語言, 在情況允許時推薦移植成物件導向程式, 提供更多解耦合的技術與接縫

---

### 第二十章 - 處理大類別

- 除了新生方法與新生物件的方式添加新特性之外
- 最重要的補救手段還是重構, 依據單一責任原則 (Single responsibility principle, SRP) 進行重構
- 重點在於找出不同的權責, 然後 grouping 與 decoupling

20.1 職責識別

- 方法 1. 方法分組
  - 把所有的成員函式列出來分類
  - 為什麼這個方法在這？它為物件做了什麼？
  - 可以團隊討論, 討論出團隊最佳的分組方式

- 方法 2. 觀察隱藏方法
  - 潛藏的成員函式, 通常意謂著一個潛藏的類別
  - 與其詢問如何測試私有函式, 不如詢問如何提成一個類別並且公開測試

- 方法 3. 尋找可以更改的決定
  - 查看一個方法中被寫死的部分
  - 試著抽出被寫死的部分成另外的方法
  - 當完成之後等同於解構了底層細節

- 方法 4. 尋找內部關係
  - 藉由查看成員變數與成員函式之間的使用情形
  - 可以藉由畫出 feature sketch 畫出各個成員變數與成員函式之間的對應關係, 箭頭方向為函式指向使用到的變數與函式
  - 可以藉此看出 grouping 並且詢問是否能抽離成一個權責更獨立的類別

- 方法 5. 尋找主要職責
  - 嘗試使用一句話描述一個類別的權責
  - 在未符合單一責任原則 (single responsibility principle) 時 , 確定是 interface 還是 implementation 
  - 使用介面隔離原則 (Interface Segregation Principle) 重構

- 方法 6. 草稿式重構
  - 在很難看出權責時, 使用草稿式重構協助清晰程式意圖

- 方法 7. 關注目前工作
  - 正在更新或者修改代表有一個完整的權責, 可以被抽取

20.2 其他技術

- 除了方法論之外, 學習 Design pattern 與閱讀更多其他人的程式碼才能提昇變識權責的能力
- 閱讀開源程式碼, 並且注意其命名與對應關係和權責分割方式

20.3 繼續前進

- 戰略, 團隊辨識出程式權責然後撰寫測試與重構, 但是時間可能不允許
- 戰術, 在沒有測試的情況下調整程式碼, 步驟請參閱書中解釋

20.4 類別提取之後

- 不要野心過大, 想要把程式一次行改到最理想的情況. 
- 而是找出理想的願景, 然後小處著手往更好的方向邁進

---

### 第二十一章 - 需要修改大量相同的程式碼

- 重構, 消除重複性, 是淬鍊設計的強大手段
- 在消除重複性的同時, 好的設計會自然浮現.
- 自然而然符合開放封閉原則 (open-closed principle)
- 書中以一個簡單的範例一步一步消除重複性, 然後反思未來擴張的情境時是否有幫助.

---

### 第二十二章 - 要修改一個巨型方法，卻沒辦法為它編寫測試

- 對付遺留程式碼常見手法, 優先使用新生方式 (方法, 物件, ...) 來避開重構或修改舊有的長方法, 巨型方法
- 遇到需要重構的巨型方法時, 首先測試難以撰寫

22.1 巨型方法的種類

- 通常都是混合型, 
- 項目條列型, 鋸齒縮排型

22.2 利用自動重構支援來對付巨型方法

- 善用自動化重構工具, 來安心的重構
- 在執行時完全使用自動化工具, 分離任何手動修改來避免引入不必要的錯誤, 
- 任何手動修改都要有測試保護

22.3 手動重構的挑戰

- 技巧 1, 引入感測變數 (sensing variable), 來協助撰寫測試的驗證, 不需要感測後即可刪除
- 技巧 2, 只提取你所了解的 (extract what you know), 小處著手, 從可以輕易理解的小地方開始抽取並且撰寫對應的測試
  - 以輸入 + 輸出的數量 (耦合數) 來作為是否是小函式的判斷
  - 可以優先處理耦合數是 0 的命令型函式, 以便了解對全域的影響
  - 從小處著手也是為了一步一步慢慢理解巨型函式
- 技巧 3, 依賴收集 (gleaning dependencies), 
  - 在無法完整撰寫測試的情形下, 優先以測試保護想要保護的地方, 然後抽離沒有測試保護的地方
- 技巧 4, 分解出方法物件 (break out method object)

22.4 策略

- 主幹提取 (Skeletonize), 遇到條件語句時, 分別提取判斷式與執行式
- 序列發現, 遇到條件語句時, 把整個條件語句抽取成一個命令函式
  - 主幹提取與序列發現是互斥的方法, 取決於對程式邏輯的理解程度來選擇使用
- 優先提取到目前類別中, 在整理時先不要移動到其他的物件中, 在擁有完整的理解後才能有更準確的設計, 一次作一種事情
- 小塊提取, 優先提取小塊程式碼, 在一步一步的小範圍抽取後讓程式意圖慢慢浮現增加理解
- 隨時準備重新提取, 提取的方式並不是只有一種, 當發現更好的提取方式後, 要依據更好的作法提取

---

### 第二十三章 - 降低修改的風險

23.1 超感編輯 (Hyperaware Editing)

- 在每次編輯時都帶著感知, 精確的理解每個輸入可能帶來的影響
- 最終會達到像是冥想的 flow state

23.2 單一目標的編輯

- Pair programming 的好處在於另一個人可以一邊監督與除錯, 讓程式設計不偏離目標
- 程式設計是一個時間只做一件事情的藝術
- 在要分心的時候紀錄下來, 優先完成手上的工作, 一次作一個. 保持好的 flow, 一次完成一件事情

23.3 簽章保持

- 在為了重建可測試時的重構時, (即沒有測試保護的修改), 請保持簽章一致來減少出錯的機會, 並且不要作多餘的修改

23.4 依靠編輯器 (lean on the compiler)

- 讓編輯器輔助時分成兩個步驟 1. 修改, 然後編譯引發錯誤 2. 修改編譯出錯的地方
- 善用編譯器的 build 與 type checking 機制, 及早的運行編譯來協助反饋
- 要注意其限制, 並不是任何錯誤都會被編譯器抓出, 例如處理繼承時

23.5 結對程式設計 (pair programming)

- 提高程式設計品質與 knowledge sharing

---

### 第二十四章 - 當你感到絕望時

- 推薦反覆看這章
- 思考有價值的地方, 不管是薪水, 還是編寫程式很有趣
- 加入社群, 研討會, ... 接觸最新的技術
- 在工作之餘, 因為興趣撰寫一些程式, 熟悉一些技術
- 團隊行動, 在團隊士氣低迷時, 一起解決一個最複雜的重構問題

---

Part III 解依賴技術

---

### 第二十五章 - 解依賴技術

- 提供 24 個在沒有測試保護, 並且為了要納入測試時的重構技術
- 有時候並不是為了更好的設計, 而是要更好的納入測試, 然後才能更放心的重構到好的設計
- 清單: 
  - 參數適配
  - 分解出方法物件 (break out method object)
  - 定義補全 (definition completion)
  - 封裝全域參照 (encapsulate global references)
  - 暴露靜態方法 (expose static method)
  - 提取並覆寫呼叫 (extract and override call)
  - 提取並覆寫工廠方法 (extract and override factory method)
  - 提取並覆寫獲取方法 (extract and override getter)
  - 實作提取 (extract implemeter)
  - 介面提取 (extract interface)
  - 引入實例委託 (introduce instance delegator)
  - 引入靜態設置方法 (introduce static setter)
  - 連接替換 (link substitution)
  - 參數化建構子 (parameterize constructor)
  - 參數化方法 (parameterize method)
  - 樸素化參數 (primitivize parameter)
  - 特性提升 (pull up feature)
  - 依賴下推 (push down dependency)
  - 換函數為函數指標 (replace function with function pointer)
  - 以獲取方法替換全域參照 (replace global reference with getter)
  - 子類別化並覆寫方法 (subclass and override method)
  - 替換實例變數 (supersede instance variable)
  - 模板重定義 (template redefinition)
  - 文字重定義 (text redefinition)

25.1 參數適配 (parameter source) 

- 為了要執行測試時的實體化, 並且希望隔離底層 API
- 介面應該傳遞職責而非實作, 越簡單越特定越好
- Legacy Code 普遍的問題是抽象層次不足, 重要的程式與底層 API 耦合

25.2 分解出方法物件 (break out method object)

- 把要測試的長方法, 移動到另一個新的物件中, 即 method object 利用新物件的建構子與成員變數來傳遞原本的參數
- 如果長方法有呼叫原物件的其他方法時, 則需要傳遞原物件的參考作為第一個參數
- 即獨立分離想要測試的方法成為另外的物件, 以方便實體化

25.3 定義補全 (definition completion)

- 在特定的程式語言中可以把定義與實作分離時, 例如 C/C++ 的標頭檔
- 可以在測試時以定義補全的方式, 定義且替換新的實作.
- 一般來說不推薦使用, 因為會產生兩個以上的實作定義, 不易維護
- 只作為最初解除初始依賴達到可測試時使用, 在可以測試後, 即可以刪除這種作法

25.4 封裝全域參照 (encapsulate global references)

- 初期解耦合重點在於引入接縫, 讓測試變得容易
- 提供一個好設計的方向
- 把各別的全域變數或全域函式, 變成單個全域物件的成員
- 這讓全域變數能夠在測試時很容易的替換掉, 並且提供在未來思考參數化等良好設計的開頭

25.5 暴露靜態方法 (expose static method)

- 在沒有測試的情況下修改最好保持簽章一致, 使用 copy/paste 降低錯誤引入
- 在想測試的函式可以被變成靜態方法時，就可以被執行獨立的測試
- 靜態方法與靜態變數意味著, 存在其他更適合存放他們的位置
- 在擁有測試保護後, 可以進行更好設計的重構

25.6 提取並覆寫呼叫 (extract and override call)

- 對於想解耦合的外部呼叫, 可以使用在物件內建立一個同名的函式作為中間層呼叫
- 物件自己的函式呼叫可以很容易的被 override 形成測試用的版本

25.7 提取並覆寫工廠方法 (extract and override factory method)

- 在建構子中寫死初始化工作, 會讓測試變得很不容易
- 在想測試的物件中, 建構子寫死了很多初始化外部物件或呼叫外函式時, 我們想要替換掉
- 把建構子裡寫死的部份抽成一個工廠方法, 並且在測試版本時可以 override 該方法

25.8 提取並覆寫獲取方法 (extract and override getter)

- 把想替換掉變數的初始化抽離成一個單體模式的 lazy getter
- 必須注意 garbage collection 的問題, 避免 memory leak
- 在測試時可以 override 這個 lazy getter

25.9 實作提取 (extract implemeter)

- 與介面提取為類似的方法
- 實作提取是把原有的具體物件變成介面 (interface) 把原有的實作全部提取成另外一個物件中
- 用來解決想要提取介面但是理想的名稱以被使用的情況

25.10 介面提取 (extract interface)

- 在得到足夠的測試之前，最好避免大規模的變動. 
- 為了測試執行的解耦合, 只需要作到能夠測試即可.
- 把想要替換的物件參照改成一個介面參考, 利用介面取代實體型別的呼叫

25.11 引入實例委託 (introduce instance delegator)

- 處理在測試中遇到問題的 static function
- 建立一個新的成員函式並且委派執行那個 static function
- 並且修改想要測試的地方的呼叫方式成為新的成員函式
- 這樣就引入了一個成員函式接縫可以透過 override 來協助測試

25.12 引入靜態設置方法 (introduce static setter)

- 處理全域變數, 好的設計是減少對全域的參考
- 處理在測試時替換單例模式 (Singleton Pattern)
- 首先要降低 constructor 的限制, 從 private 變成 protected
- 並且建立一個 static setter 來執行替換工作

25.13 連接替換 (link substitution)

- 使用 linker 機制達到替換功能
- 例如 C 語言的 linker, Java 的 object library mapping

25.14 參數化建構子 (parameterize constructor)

- 避免在建構子中寫死實體化, 最好全部都變成參數化, 才容易測試
- 避免修改簽章, 可以使用 constructor overload 達成或者 default parameter 的方式達成
- 實體化最好都發生在外部

25.15 參數化方法 (parameterize method)

- 等同於參數化建構子

25.16 樸素化參數 (primitivize parameter)

- 不推薦使用, 因為並沒有導向更好的設計而是延遲問題
- 以自由函式實作新功能

25.17 特性提升 (pull up feature)

- 把想要測試的函式, 移動到一個 abstract class 中
- 讓測試可以只實例化那個類別並且可以用 override 取代

25.18 依賴下推 (push down dependency)

- 把不想在測試時引入的依賴, 移動至新的子類別中
- 繼承不是最佳的設計, 但是為了方便測試可以使用這種方式
- 更好的設計是改成委託其他物件執行

25.19 換函數為函數指標 (replace function with function pointer)

- 使用函數指標取代函數呼叫, 因此可以讓不同環境呼叫不同的函數實體
- 這是一個 build time 決定的功能, 如果是在 C 語言時常使用, 推薦考慮把專案轉移到 C++ 上

25.20 以獲取方法替換全域參照 (replace global reference with getter)

- 建立一個 getter function 取代直接呼叫全域參考
- 這讓我們可以使用 override 建立測試版本

25.21 子類別化並覆寫方法 (subclass and override method)

- 使用繼承來建立測試版本的子類別並且 override 
- 需要注意存取權限, 否則沒辦法實現繼承

25.22 替換實例變數 (supersede instance variable)

- 提供 setter function 替換變數
- 這種方式是危險的, 因為原先我們並不希望可以任意替換變數, 可以透過命名函式前綴為 supersede 來區隔. 作為測試時用函式

25.23 模板重定義 (template redefinition)

- 在擁有 template 語法的程式語言中可以使用, 但是仍然可以優先考慮繼承類的方式
- 使用 template 抽離類別

文字重定義 (text redefinition)

- 在一些直譯語言中, 可以動態替換名稱
- 或是 C/C++ 語言的預處理的類似功能

---

### 第二十六章 - Appendix 重構

- 推薦參考 Martin Fowler 的 refactoring 原著
- 簡單介紹 Extract Method 的重構步驟

---

438