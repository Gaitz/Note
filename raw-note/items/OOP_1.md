## 深入淺出物件導向分析與設計

### Head First Object-Oriented Analysis & Design 中文版, ComputerScience/OOP

---

第一章 - 良好應用程式之基石

第二章 - 收集需求

第三章 - 需求變更

第四章 - 分析

第五章 - 良好的設計

第六章 - 彈性的軟體

第七章 - 解決真正的大問題

第八章 - 架構

第九章 - 設計原則

第十章 - 反覆與測試

第十一章 - OOAD 生命週期

---

### 第一章 - 良好應用程式之基石

- 軟體設計的流程
  1. 需求探索, 確認需求
  2. 應用基本設計原則, 建立有彈性的軟體
  3. 努力達成可維護, 可擴充的設計
- Bad Smell 1. 避開字串比較, 改用 enum 或其他模式
- 以**測試驅動** (Test Driven) 進行程式設計
- Bad Smell 2. 不要傳遞無用的值 (null)
- **物件基本原則**
  1. 物件函式命名與物件本身有絕對相關
  2. 物件本身應該只代表一個**概念**
  3. 如果有 null 就代表多個概念應該切割概念
- 基本技巧 1. **封裝** (encapsulation) 任何時候看到重複的程式碼就該封裝起來
  - 重用, 抽離相同的概念, 隱藏細節, 分離抽象層
- 基本技巧 2. **委派** 相依性注入 (dependency injection)
  - 高內聚低耦合, 常變動的內容作為相依性注入, 相依性抽離, 開放封閉原則

---

### 第二章 - 收集需求

- **use case 使用案例, 描述系統要如何達成某一個特別的顧客目標**
  - 主要關注在**做什麼**
  - 每一個使用案例會包含一個或多個 scenario 來傳達系統如何與 end user 或其他系統互動來完成特定的目標
  - 會包含 **clear value** 清楚的價值, **起點與終點**, **外部啟動者** external initiator
  - 如果系統有多個目標則需要有多個對應的使用案例 use cases
- **關注程式語言的垃圾回收機制, 包含自動與手動的方式**, 尤其是學習如何增進效能 (手動或自動的方式)
- 對於替代路線, 預估事情可能出錯的方式並且測試這個路徑
- 利用使用案例來揭露不完整或遺漏的需求
- 所有的使用案例會集合成一組需求清單, 需求清單會涵蓋所有的使用案例

---

### 第三章 - 需求變更

- 需求改變意味著程式需要改變
- 為新的需求撰寫新的使用案例 use case
- 替代路徑 optional, alternate path 在 use case 中的 if else
- 遇到重複的程式碼, 不要複製而是思考如何**搬到適當的地方重複使用**, 更好的系統設計, 提高可維護性
- 需求 -> 程式更變 -> 系統改善, 如同 TDD 的紅綠燈

---

### 第四章 - 分析

- 分析軟體在真實世界遇到的情境
- 使用委派 delegate 產生 loosely coupled 的程式碼
  - 隔離實作細節來保護原有的其他物件
- 從使用案例 use case 中抽出所有的**名詞**與**動作**, 這些可能就會產生對應的系統物件與方法
  - 這種整理並且產生設計的方式稱為文本分析 textual analysis
  - DDD
  - 因此好的使用案例會產生好的系統
  - 好的使用案例以容易了解的文字, 清楚且精準的描述系統在做什麼
- **Unified Modeling Language, UML** 用來描述類別關係的統一語言
  - 一個類別會包含名稱, 屬性, 動作
  - 類別之間的關係使用實心箭頭線, 表示包含關係, 並且可以附帶數字代表數量
- UML 圖提供一個系統的概觀, 用來協助設計與討論

---

### 第五章 - 良好的設計

- 當沒有對應的 object 會產生時, 使用 **abstract class** 提升儲存共用的屬性與方法
  - `abstract` 代表無法生成對應物件 (construct)
  - 實際類別以繼承的方式取得
- 每當找到兩個以上的共同行為時, 就應該思考重用性, 放到適當的地方然後重用
- 更多 **UML**
  - 名稱斜體代表 **abstract**
  - 空心箭頭, 代表 **generalization**, **inheritance**
  - 空心菱形箭頭, 代表 **aggregation**
  - 實心菱形箭頭, 代表 **composition**
  - 介面 (interface) 以名稱以斜體 + **<\<interface\>>** 表示
- 測試程式是否設計良好的方法就是時常的改變他
- **程式應該相依於介面 (interface) 而非實作 (implementation)** 可以提高彈性與隔離
- **確保一個類別只有一個理由改變**, 盡可能減少變動已有的程式
  - **如果一個類別有超過一個改變的理由, 則應該被分拆到其他物件去**

---

### 第六章 - 彈性的軟體

- 當發現設計有問題的時候並且不知道解法, 可以通過思考所有的 OOP 原則
  - 繼承 Inheritance, 多型 Polymorphism, 抽象化 Abstraction, 封裝 Encapsulation
- 遇到問題時重新思考原先的設計, 先前的決策可能就是痛苦根源
  - 設計是 iterative 進行的, 必須願意修改自己或他人先前的設計
  - 大多數好的設計都是透過分析壞的設計而來
  - 撰寫更多的軟體才能精通設計之道
- **封裝變動之物**, 任何時候看到或預期會變動的某物應該找個方式進行封裝
  - 當有跨物件的變動出現時, 可以思考以 collection 的方式動態儲存
- 使用繼承時, 父類別與子類別應該是因為**行為有變動**才產生繼承
- 好的設計更變容易性十分高, 代表程式非常動態有彈性
- **cohesive 內聚性**, 該類別只做好一件事情並且不嘗試做其他之外的事情
  - 可以藉由檢查所有的方法與類別之間的關係
  - 關注把一件事情做好, 並且關注不要做其他事情
  - 代表是 well-defined
  - 高內聚讓變動更容易, 並且減少對其他類別的依賴或改動
  - 高內聚自然會形成低耦合, 是相輔相成的
  - 也意味著容易擴充與重用
- 偉大的軟體通常是夠好的, 而非完美的
  1. 確認顧客高興 (使用者高興)
  2. 確認設計具有彈性 (高內聚低耦合)

---

### 第七章 - 解決真正的大問題

- 面對真實事件大型應用程式時
- 把大問題視為個別功能 (functionality) 的集合
  - 即可個別解決
- 概念回顧
  - 封裝 encapsulation 變化之物
  - 需求探索, 使用案例 use cases
  - 針對介面 (interface) 而非實作 (implementation) 減少依賴, 降低耦合
  - 高內聚的偉大軟體, 容易改變與擴張並且完成客戶所需
  - 分析在真實世界下的情境 context
- 流程 1. 更多資訊
  - 除了空泛的遠景之外, 需要詢問出希望系統**像什麼**與**不像什麼**, 更多實際的資訊
  - 從中取得系統具體的功能
  - **功能 feature** 是系統需要做的事情的**高階描述**, 通常由訪談中會得知
  - **為了滿足一項功能, 會產生多個系統需求**
  - 系統功能來自客戶, 系統需求來自開發者
- 流程 2. 建立 use case diagram 使用案例圖
  - **把系統功能建立成使用案例圖, 並且確認使用案例圖包含所有的系統功能**
  - use case diagram 不同於 use case 的細節描述, 而是以圖示說明系統的大綱, 避免深入細節
  - 每個圖示都能產生出更細節的 use case
  - 描述**系統內**與**系統外**的大項目, 取得系統 big picture
- 流程 3. Domain Analysis
  - 與客戶討論並且使用客戶的語言來描述系統
  - 領域分析來避免建造責任範圍以外的內容
  - 補充: Domain Driven Design, DDD
  - 補充: 最好還能形成驗收測試
- 流程 4. 大分解
  - 在客戶認同與確認 big picture 後, 開始分解成系統核心元件 (package, module)
  - Design Pattern 與其他 software architecture 可以在這個階段參與進來
  - Design Pattern 不是進入程式設計, 而是以知識的方式進入設計師的腦袋, 才可以辨識與採用好的設計
  - 例如: 使用 Model-View-Controller, MVC pattern

---

### 第八章 - 架構

- 決定實現順序
- Architecture 架構指的是系統設計與最重要的部分和每個模組之間的互動
- 架構三問找出執行順序
  1. 找出系統本質 (essence) 以詢問這個功能如果不存在的話對系統的影響來決定
  2. 提早面對模糊的功能, 不清楚不明確的功能, 應該提早面對
  3. 提早面對未知的實作, 全新的程式任務或不熟悉的問題處理
- 執行的順序取決於**風險**
  - 重要的東西沒辦法完成的風險
  - 未知的實作或需求帶來的風險
  - 過早最佳化的複雜度風險
- 實作時該思考考的是**有哪些風險並應該如何降低風險**
  - 優先處理關鍵功能, 來減少專案風險
  - **在減少風險時不要分心於其他事情**, 避免花時間在無助於減少風險的事情上
  - 在減少風險後, 會有更多的時間來處理其他事情
- 實作功能時以已經建立的相關功能為順序
  - 相關的功能, 一同建立更容易看出系統的 relationship 互動關係
- 實作時以**共同性 (commonality) 分析**類別關係
  - 比較設計時, 以假想的擴充作為分析基礎, 即可得知哪個設計更好擴充
  - 好的設計會降低變動風險
- **減少風險然後才寫程式**
  - 需要更多的與客戶討論與確認
  - **客戶關心的不是偉大的程式碼而是偉大的軟體**
  - **目標是減少延遲支付與不合客戶預期的軟體**

---

### 第九章 - 設計原則

- Design Principles 設計原則
- 開閉原則 **Open-Closed Principle, OCP**
  - closed for modification, 禁止修改
  - open for extension, 允許擴充, (例如 override method)
  - 反向來說, 如果新需求就必須修改舊的程式碼而非擴充的話, 則代表舊的設計缺乏彈性
  - **開閉原則關心的是彈性**
  - 撰寫長期有效的程式碼, 並且不希望被修改, 但是新需求出現時允許擴充
  - 封裝 encapsulation 與抽象化 abstraction 的結合, 尋找保持不變的共同行為封裝起來與因為需求而出現的變動區隔
- 不重複原則 **Don't Repeat Yourself Principle, DRY**
  - 抽取共同之物放在同一個地方, 避免重複的程式碼, 以此合理的分解系統功能
  - **DRY 原則關心的是每個功能只實作一次並且放在最合理的位置**
- 單一責任原則 **Single Responsibility Principle, SRP**
  - 每個物件應該只有一個責任, 而整個物件所有的服務都聚焦在這個責任上
  - 符合 SRP 則代表了高內聚力
  - 在物件導向時, 可以用簡單的句子判斷合不合理 _The 'ObjectName' 'ObjectMethod' 'MethodParameters' itself._
- Liskov 替代原則 **Liskov Substitution Principle, LSP**
  - 子型別 subtype 必須能替代基礎型別 base type, 即**把子類別替換成基礎型別後所有的方法都應能正常使用**
  - **關注在合理的使用繼承**
  - 繼承是一個強大的關係, 因此要避免誤用, 避免繼承不合理的方法
- **Inheritance** 繼承之外的程式碼重用方式, 並且應該優先使用繼承以外的方式
  - 幾種方式沒有單一的實作方式, 而是被引用的 object 有不同的 lifecycle 來做區分
  - **delegation** 委派, 使用在想要利用其他物件的功能性並且不需要改變時, 簡單來說就是呼叫其他物件來完成目標
  - **composition** 合成, 將其他多個類別的行為組合起來並且組合的物件 lifecycle 受到控制 (持有 owning)
  - **aggregation** 聚合, 如同合成, 但是傳入的物件並不被擁有, 即組合的物件 lifecycle 不受到控制 (不持有)

---

### 第十章 - 反覆與測試

---

### 第十一章 - OOAD 生命週期

---
