## Clean Code and The Clean Coder

### Clean Code 與 The Clean Coder, 中文版, ComputerScience/Mindset

---

Clean Code

第一章 - 無瑕的程式碼

第二章 - 有意義的命名

第三章 - 函式

第四章 - 註解

第五章 - 編排

第六章 - 物件及資料結構

第七章 - 錯誤處理

第八章 - 邊界

第九章 - 單元測試

第十章 - 類別

第十一章 - 系統

第十二章 - 羽化

第十三章 - 平行化

第十四章 - 持續地精煉

第十五章 - JUnit 的內部結構

第十六章 - 重構 SerialDate

第十七章 - 程式碼的氣味和啟發

第十八章 - 平行化之二

The Clean Coder

第一章 - 專業主義

第二章 - 說不

第三章 - 說是

第四章 - 寫程式

第五章 - 測試驅動開發

第六章 - 練習

第七章 - 驗收測試

第八章 - 測試策略

第九章 - 時間管理

第十章 - 預估

第十一章 - 壓力

第十二章 - 協作

第十三章 - 團隊與專案

第十四章 - 輔導、學徒期與工藝典範

第十五章 - 工具

---

Clean Code

---

### 第一章 - 無瑕的程式碼

- 概略的描述 clean code 是什麼
- 我們為什麼需要 clean code
- 不好的程式會形成阻礙, 壞的程式會導致嚴重的後果
  - 劣質的程式碼導致了公司的倒閉
  - 不好的程式碼構成了阻礙，那又為什麼要撰寫這樣的程式碼呢?
  - 雜亂的程式碼會拖慢開發的速度直到根本改不動, 最後變成 rewrite 整個系統, 然後產生新的雜亂程式碼周而復始
- 待會兒等於永不, **LeBlanc's law: Later equals never**
- **造成雜亂程式碼的根本原因在於程式設計師不夠專業**
  - 如果程式設計師遵守不懂劣質程式碼風險主管的意願, 代表程式設計師也一樣不專業
- 讓開發速度加快的**唯一**方式是 clean code
  - 隨時隨地都確保程式碼盡可能的整齊潔淨
  - 爛的程式碼不會讓你因此趕上截止日, 只會讓開發速度更慢
- Clean code 的藝術
  - 具有程式感, 看到雜亂程式碼的同時知道有哪些更好的選擇, 知道如何改變
- **更容易閱讀才會更容易撰寫**
- **童子君規則: 持續地保持 clean code, 每次 commit 都更乾淨一點點**
  - vs. 破窗理論
- **重複的程式碼代表我們的想法沒有被適當的表達在程式碼中**
  - 試圖弄清楚是什麼，然後試圖把想法表達的更清楚
- 我們是作者, 程式碼的作者, 與讀者有良好的溝通是作者的**責任**
  - 記得你就是作者, 讀者會對你的作品下評論
  - 在撰寫新程式碼之前, 我們總是閱讀舊的程式碼
  - 因此讓程式碼更容易閱讀, 也會讓程式碼變得更容易撰寫
  - 你今天寫程式的難易度, 取決於周邊程式碼的可閱讀性高低
- clean code 是
  - 十分注重細節
  - 優雅的、令人愉快的
  - 專注表達單一意圖
  - 簡單明瞭、俐落的抽象概念
  - 只包含必要的資訊，讓讀者感受到我們的果決
  - 包含測試的, unit test, acceptance test
  - 盡可能減少相依性
  - 被細心照料的
  - 沒有重複的程式碼
  - 具有表達力的
  - 提早建立簡單抽象概念
  - 執行結果如同想像的
  - 看起來像是為了解決該問題而存在的

---

### 第二章 - 有意義的命名

- **認真嚴肅地對待命名**
- **一發現有更好的命名就立刻替換掉原本的名稱**
- 如果一個名稱還需要註解輔助就代表他不具備展現意圖的能力
- 命名的用處在於讓程式本身提供上下文資訊 (context)
  - 顯示出存在的意圖

**避免誤導**

- 避免留下喪失程式原意的錯誤線索
- 小心過於相似的名稱, 不容易在第一時間判斷出不同

**產生有意義的區別**

- 無意義詞彙是多餘的, 沒有區分性
  - Ex. _Data_, _Info_
- 要區別名稱，就用讀者能辨識出不同之處的區別方式

**使用能唸出來的名稱**

- 字詞應該是能夠發音的，讓閱讀時能使用到人腦的語言功能

**使用可被搜尋的名字**

- 長命名勝過短命名
  - 短命名造成搜尋的困難
- 命名的長度應該與他的存活 scope 成正比

**避免編碼**

- 不要在命名上額外提供一套規則的資訊, 像是
  - 型別代號
  - Member Prefixes, 用額外命名來區分物件成員或是函數參數
  - Interfaces 和 Implementations, 不要為 interface 增加額外的命名資訊, 加在 implementation 上, 好的程式應該相依於 interface 上, 不必額外透露出是 interface 或是 implementation 給使用者

**避免思維的轉換**

- 專業的程式設計師知道清楚明白才是王道
  - 專業人士運用本身的好能力, 寫出讓別人可以了解的程式
- **命名應該使用讀者所熟知的名稱**

類別的命名

- 應該使用名詞或名詞片語
- 不應該是動詞

方法的命名

- 應該使用動詞或動詞片語
- 當對 constructor 被 overloaded 時, 應該提供包含參數資訊的靜態工廠方法取代直接呼叫 constructor
  - 考慮強制將 constructor 設為 private 都由有意義的 static factory method 取代

不要裝可愛

- 命名上賣弄小聰明、幽默、俚語、俗語

**每個概念使用一種字詞**

- **替單一抽象概念挑選一個字詞, 並堅持持續的使用一致的詞彙**
  - 固定的、一致性的命名規則
- 範例: 無法區分的 _controller_, _manager_, _driver_

**別說雙關語**

- **一個詞彙不能多於一種目的**
- 身為作者，我們的目標是讓程式碼盡可能易於理解，可以快速瀏覽不需要時間奮力苦讀

**使用解決方案領域的命名**

- 取決於讀者是誰,
- 讀者是程式設計師, 因此應該盡可能使用程式設計師彼此本身就知道的知識領域命名, 像是 pattern 的慣用詞, 演算法名稱, ...

**使用問題領域的命名**

- 如果沒有解決方案的命名方式 (程式設計師熟悉的術語) 時,
- 使用問題領域 (domain language) 的命名, 起碼維護程式碼時可以詢問業務相關人員 (領域專家) 命名含意
- **將程式碼區分成解決方案領域和問題領域**, 是專業程式設計師該做的工作, 在適當的時機使用適當的命名

**添加有意義的上下文資訊 (context)**

- 命名意義, 很難從單獨的命名中取得足夠的資訊, 大多數時候需要配合 context 命名
- _grouping_ 把單獨散落的命名聚合成物件或集合, 以程式碼的方式展現出 context
- 改善上下文資訊並且讓演算法變得清晰
- _補_: **當有多個零散的區域變數時, 就是個時候把它聚合成一個概念**, 變成物件, 另外的程式,

**別添加無理由的上下文資訊**

- 當能用更簡潔的方式命名時, 就不需要額外添加 context 資訊的長命名

總結

- 別讓重新命名阻礙你的前進
- 以重構工具協助解決可閱讀性的問題 (renaming tool)

---

### 第三章 - 函式

---

### 第四章 - 註解

---

### 第五章 - 編排

---

### 第六章 - 物件及資料結構

---

### 第七章 - 錯誤處理

---

### 第八章 - 邊界

---

### 第九章 - 單元測試

---

### 第十章 - 類別

---

### 第十一章 - 系統

---

### 第十二章 - 羽化

---

### 第十三章 - 平行化

---

### 第十四章 - 持續地精煉

---

### 第十五章 - JUnit 的內部結構

---

### 第十六章 - 重構 SerialDate

---

### 第十七章 - 程式碼的氣味和啟發

---

### 第十八章 - 平行化之二

---

The Clean Coder

---

### 第一章 - 專業主義

---

### 第二章 - 說不

---

### 第三章 - 說是

---

### 第四章 - 寫程式

---

### 第五章 - 測試驅動開發

---

### 第六章 - 練習

---

### 第七章 - 驗收測試

---

### 第八章 - 測試策略

---

### 第九章 - 時間管理

---

### 第十章 - 預估

---

### 第十一章 - 壓力

---

### 第十二章 - 協作

---

### 第十三章 - 團隊與專案

---

### 第十四章 - 輔導、學徒期與工藝典範

---

### 第十五章 - 工具

---

33 = 18 + 15
