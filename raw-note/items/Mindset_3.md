## The Pragmatic Programmer

### The Pragmatic Programmer, 中文版, ComputerScience/Mindset

---

第一章 - 務實的哲學

第二章 - 務實的方法

第三章 - 基本工具

第四章 - 務實的偏執

第五章 - 彎曲或弄壞

第六章 - 並行

第七章 - 當您寫程式時

第八章 - 專案啟動前

第九章 - 務實的專案

第十章 - 後記

---

### 第一章 - 務實的哲學

- 提示 1. `重視您的手藝`
- 提示 2. `思考!您的工作` Think!
  - 思考取代直覺

這是您的人生

- 提示 3. `您擁有改變的能量`
  - 行動! 這個行業有各種不同的可能性

貓吃了我的原始碼

- 不害怕承認無知和錯誤，務實的面對問題的發生，並且我們會盡可能專業的處理他
- **團隊信任**，互相信任的團隊，團隊能信任你，你也能信任團隊
- **負責**，對自己的承諾負責。並且有權拒絕承諾風險過高和做不到的責任
- 提示 4. `請提供解決問題的選擇，停止製造爛藉口`
  - 當問題出現時，應該要做的是提供解決方案的選擇，而非藉口。
  - 藉口意味著不專業，像專業人士一樣承擔責任與提供解決方案

軟體亂度 entropy

- 提示 5. `不要讓破窗存在` **重要**
  - 良好的軟體是需要時常的維護
  - 取決於做專案時的文化與心理
  - 避免亂度在軟體中擴散
- **首先，不要傷害**
  - 不要因為出現危機就進行附帶傷害的解決方案，一個問題已經夠麻煩了。

石頭湯與煮青蛙

- 提示 6. `成為改變的催化劑`
  - 記得石頭湯士兵的故事
- 提示 7. `記得大方向`
  - 除了自己在做的事情之外，需要經常環顧周圍發生的事情，關注大局。
  - 避免成為溫水煮的青蛙
- **訓練**事態感知 situational awareness
  - 養成如同特種部隊一般，時時刻刻注意和仔細觀察周圍環境的習慣

夠好的軟體

- **承諾不可能實現的完成時間，和為了滿足最後期限而偷工減料，兩者不專業的程度是相同的。**
- **足夠好的軟體就是最好的軟體**
  - **讓使用者參與功能的取捨和品質的取捨**
  - 避免功能膨脹 feature bloat, **記得多數軟體被使用到的只有少數幾個核心的功能**, 更多的功能代表可能引進更多的 bug 或安全性問題
- 提示 8. `把品質看成一種需求`
  - 很多時候對於使用者來說，今天堪用的軟體勝過明天完美的軟體
- **知道何時停手**
  - 如同繪畫一般
  - 不要因為過分的修飾和精煉而破壞了完美的程式，去做下一件事
  - 程式碼可能並不完美，但是也不用擔心。也不可能是完美的

您的知識資產

- **對知識的投資永遠都得到最好的回報**
  - 知識與經驗是會過期的資產
  - **更重要的是學習新事物的能力是最重要的戰略資產**
- 投資知識資產，如同長期投資使用一樣的原則
  - **定期投資**
  - **多樣化**
  - **管理風險**
    - 平均投資在高風險與低風險上
  - **低買高賣**
    - 在某項技術變流行之前就學習他，衝浪!
  - **審查和調整**
    - 定時的審查和調整
- 提示 9. `請定期投資你的知識資產`
- 適當的目標
  - **每年至少學一門新語言**
  - **每個月閱讀一本技術書**, 想要深入理解, 仍然需要長篇的書籍
  - **也要閱讀非技術類書籍**, 軟體是被人所使用, 應該更瞭解整個社會和人
  - **上課**, 尋找有趣的課程
  - **參與本地使用者群組或會議**, 了解公司以外的人在做什麼，不要只去聽要積極的參與, 孤立對你的職業生涯可能是致命的
  - **體驗不同的環境**, 各種不同的開發環境, Windows, Linux, IDE, editor, ...
  - **了解目前發展**, 閱讀和當前專案不同的技術相關文章
- 學習的過程會擴張思維，思維的交叉交流很重要
- 把握學習的機會, **遇到問題, 疑問, 不知道的事情時, 不要讓事情就這麼過去**
- 提示 10. `批判式的分析你讀到或聽到的東西`
- **批判性思考**
  - 五個為什麼, 深入問題的, 一層一層的詢問為什麼
  - 這對誰有好處, follow the money
  - 時空背景是什麼? 對誰最好, 先決條件是什麼? 短期和長期的影響?
  - 何時何地可用? 什麼情況下, 什麼時候, 後果的後果是什麼?
  - 為什麼會有這個問題? 是否有某種模式讓問題發生? 底層是怎麼運作的?

溝通

- 提示 11. `將您的母語視為另外一種程式語言`
  - 溝通! **重要**
  - 了解你的聽眾, 溝通是建立在聽眾聽得懂的事情上, 成功的傳達
  - 知道你想說什麼, 優先思考和精煉大綱和要表達的東西, 之後才是寫作
  - 選擇適合的時間, 在對的時機討論對的事情
  - 選擇一個風格, 配合聽眾調整輸出的風格
  - 讓他看起來棒棒的, 文件的品質看起來好看也很重要
  - 當一個聆聽者
  - 回覆別人, 訊息, email, ...
- 提示 12. `您說了什麼話，與您如何說這些話一樣的重要`
- **溝通越有效, 影響力越大**
- 提示 13. `內建文件說明，不要硬綁上去`
  - 說明文件, 最好是依附著程式碼
  - 文件是軟體開發過程的一部分, 並且應該遵循軟體品質
  - **記得 DRY 原則, 不要讓程式碼與註解說一樣的事情**

---

### 第二章 - 務實的方法

- 目標是產出靈活且適應性強的軟體

優秀設計的精隨

- 提示 14. `一個好的設計比爛設計更容易改動`
  - ETC, Easier to Change, **重要**
  - 對於東西來說**使用者容易習慣使用**就是好設計
  - 對於程式來說開發者**容易改變**就是好的設計
- ETC 是一種價值觀, 一個 guide
  - **學習新想法時初期應該刻意的使用這些想法, 直到它變成環境觀察的一部分**
  - 跟隨 ETC 的想法做決策並且應該嘗試改變程式碼來確認, 持續做著這件事情系統會自然而然形成低耦合 loose-coupling 與內聚性 cohesion
- **嘗試紀錄決策, 形成決策日誌, 可以用來回顧與參考**

DRY - 重複的罪惡

- 維護並不是一個獨立的活動, 而是整個開發過程中的常態活動
- 在維護時我們必須**找到**並且**修改**
- 提示 15. `DRY 原則 - 不要重複`
  - 在一個系統中,每一條知識都必須有一個單一的, 明確的, 權威的表述
  - **重要** 最重要的工具之一
  - DRY 指的是**知識**與**意圖**, 而非單純的重複的程式碼或者表達型態
  - **環境觀察**: 在修改時是否需要在其他地方進行修改, 儘管表達方式可能不同
- 不是所有重複的程式碼都屬於知識複製
  - DRY 原則需要挑出來的是重複的知識, 而非重複的程式碼
  - 重複的程式碼但是乘載不同的知識, 那麼程式碼的相似只是巧合而已
- 文件的重複 (程式碼與註解之間的重複),
- 資料的重複 (可運算的資料變成變數需要額外的維護)
- 表示形式的重複, 內部 API 之間的重複與外部 API 之間的重複 (應該以集中存放與統一格式標準設計)
- 開發者的重複 (重點在於 knowledge sharing, 只有知識能被交流才有可能重用)
  - 實務上可以建立 daily scrum standup meeting,
  - 建立非同步的討論區 slick, wiki, 永久儲存且討論
  - 每個 codebase 存在一名專案圖書館員, 工作是促進知識的交流, 包含了促進 code review, 把共用函式放在相同的地方, ...
- 提示 16. `容易重複使用`
  - 建立一個容易找到且重用現有內容的環境,
  - 沒有這樣的環境, 人們就不會重用程式碼, 沒有重用就有重複知識的風險
- 封裝的模組與資料結構, 應該對外使用統一的標記法, 不應該洩漏內部是使用 cache 或計算

正交性 orthogonality

- 獨立 (independent), 去耦合 (decoupling), 線性獨立, 高內聚的 (cohesion)
- 提示 17. `消除不相關的東西對彼此造成的影響`
- 提高生產力
  - 修改被限制在特定的部分, 減少測試與開發的時間
  - 更容易重用
  - 正交的元件能形成的組合更多, 在組合後提供更多的功能
- 降低風險
  - 問題被隔離在特定的部分
  - 可以針對特定部分進行修改與修復
  - 更容易測試
  - 不予外部 (供應商, 產品, 平台, 第三方) 耦合, 以介面隔離於部分
- 個別的元件相依於抽象的介面, 而非實體
- **如果我大大改變某個特定功能背後的需求, 會有多少模組受到影響?**
  - 以這個問題詢問來測試正交性, 理想的情況下是 1
- 還要檢視系統對於真實世界的相依性
  - 避免相依於無法控制的東西
- **工具集與函式庫**
  - **明智的選擇引入的技術, 注意到系統的正交性**
  - 想想 Design Pattern
- 撰寫程式碼
  - 在撰寫程式時, 很容易就破壞正交性, 也許是重複的知識與功能
  - **讓你的程式保持著去耦合的狀態**
  - **避免全域變數** (儘管只是 read 在轉換成多執行緒時仍然會發生問題)
  - **避免相似的功能**
  - 養成不斷批評自己程式碼的習慣, 並且尋找任何機會重新組織他 (refactoring)
- 測試
  - 具正交性的系統更容易測試
  - **撰寫單元測試同時也是很好檢視正交性的方式**
  - 在進行 bug 修復時, 也是檢視系統正交性的好時機, **紀錄 bug 修復時所影響的模組或檔案數量**, 並且每個月追蹤檢視
- **總是保持正交性**
  - **盡可能地符合正交性與 DRY 原則**, 這樣的系統會更靈活, 容易理解, 容易除錯, 測試, 維護, 新增功能, ...

可逆性 reversibility

- 僵化來自於關鍵的決定不容易被逆轉
- 應該使用不同的方式**讓我們不必做關鍵且無法逆轉的決定**
  - 例如 DRY 原則, 去耦合, 外部設定
- 與資料庫系統的綁定, 應該建立在對資料庫概念的抽象化上
  - **系統應該相依在對於概念抽象化的介面上**, 而非任何的實體
- 提示 18. `根本沒有所謂的最終決定`
- 無法預測未來的變化與需求, 想想軟體架構的演進
  - 我們要做的是**讓改變變得容易**
- 提示 19. `不去管未來流行什麼`

曳光彈 tracer bullet

- Tracer bullet 在黑暗中提供即時且真實的回饋
- 提示 20. `利用曳光彈找到目標位置`
- Tracer bullet development
  - 概念等同於 Agile 開發, 擁抱改變小型迭代並且可運作的程式
  - 以小型路徑建立 end-to-end 的穿破所有層的架構
- 優點:
  - 使用者可以即早看到成果並且提供反饋
  - 開發人員建構了一個工作架構, 一個 end-to-end 都存在的架構
  - 有一個整合平台, 當架構存在後即存在一個可以時常執行 unit test, integration test 的平台
  - 有成果可示範, 永遠有一個可運行的成果, 可以展示 demo
  - 能感受到進步, 迭代的進步是可視的
- 曳光彈並不會總是擊中目標
  - **改變應該是容易且快速完成的**
- Prototyping 與 tracer bullet development 的差別
  - Prototyping 在建立原型後會丟棄所有的實作, 並且以學到的經驗重新撰寫程式
  - Prototyping 可以做為 tracer bullet development 的前導偵查
- Tracer bullet development 開發的程式碼就是最終系統中的一部分

原型和便利貼

- Prototyping 在早期以低成本建置, 目的在於分析, 揭露風險, 學習
  - 並不一定需要寫程式, 常常以白板, 便利貼, 即可建立提供思考
  - 細節不重要
  - 最終將會丟棄, 建立在此之上應該低成本的建立, 否則就是 tracer bullet development
  - **正確的使用 prototyping 帶來的是在開發早期識別且糾正潛在的問題點**, 以節省大量的金錢, 時間, 痛苦
- 如果處於**無法放棄細節**的環境, 應該改用 tracer bullet development 取代 prototyping
- 對於任何未知, 有疑慮的事物皆可進行 prototyping
- 提示 21. `原型的目的是學習`
- 建置原型時可以忽略 正確性, 完整性, 強健性, 風格
- 在 prototyping 時通常**希望回答特定領域的問題**, 例如
  - 主要領域的權責是否明確且適當?
  - 主要元件之間的協作是否定義良好?
  - 耦合是否已經最小化?
  - 能否找出潛在的重複部分?
  - 可否接受介面的定義與限制?
- 當環境且文化中, 使用 prototyping 會有誤解時, 應該改用 tracer bullet development

領域語言 domain languages

- 提示 22. `緊靠問題所在的領域`
- 使用問題領域的詞彙, 語法, 語意
- 內部的領域語言, 例如 RSpec, Phoenix, 固定於特定語言的語法上
- 外部的領域語言, 例如 Cucumber, Ansible, 以文件符合特定標準存在, 需要配合其他實作的解析器使用, 因此不會受限於單一語言上
- 建議: **花費的努力不要比省下的錢多**, 自行定義領域語言會增加成本, 並且需要確保節省下來的錢更多

評估 Estimating

- 預估是一個需要學習並且發展的技能
- 提示 23. `評估可以免除驚嚇`
- **回答的單位會影響精確度的預期** 重要
  - **慎選回答時的單位**
  - 範例: 回答 130 個工作天與 6 個月, 所預期的精確度範圍是不同的
- 預估最好的方式來自於**問已經做過的人**或有類似經驗的人, **成功借鑒他人經驗**
- 流程
  - 理解被問的問題, **重點在於範圍 (限制)**
  - 建立系統模型, 預測時的心理模型
  - 將模型分解為元件, 思考每個元件之間的**互動**與**參數**
  - 將每個參數都給一個預估值, **重點在找出哪些參數影響結果最大, 並且盡可能地讓這項參數預測值更正確**
  - 計算答案
- **紀錄每次的評估**
  - **在預估錯誤時, 找出問題點, 提升預估能力**
- Program Evaluation Review Technique, PERT
  - 預估時不是回答單一結果, 而是一個區間
  - 最樂觀的預估值, 最有可能發生的預估值, 悲觀的預估值
- 對於專案預估最準確的方式是**建立在同一專案多次迭代的經驗**
  - 以 incremental development 進行
  - Agile 在多次迭代後, 能提供更準確的預測
- 提示 24. `使用程式碼迭代時程`

---

### 第三章 - 基本工具

- 工具會放大才能, 工具越好越熟練使用, 效率就越好
- 打磨且充實自已的工具庫, 並且在不夠用時, 向外探索尋求適合的工具

純文字的威力

- 程式設計師的**基礎原料是知識**
- 提示 25. `在純文字中保存知識`
- 有結構的純文字, 例如 HTML, JSON, YAML
- 純文字的優點
  - 不會過時, 確保純文字的 human understandable
  - 利用現有工具, 純文字檔案可以很好的被 _version control_, _diff_, _checksum_
  - 更容易測試,
  - 更好搜尋
- 最小共用分母, 無論科技如何發展, 純文字始終是共用的標準

Shell

- shell 等同於木工的工作檯
- 提示 26. `善用命令 Shell 的力量`
- shell 能更好的自動化, 並且提供完整的功能, 與客製化的能力
- 有時候我們會客製化 shell 的 color theme, prompt, alias, autocomplete 等等

Editor

- 提示 27. `熟練編輯器`
- 練習無滑鼠操控編輯器
- 流暢使用編輯器
  - 以字元, 單字, 行, 段落, 移動且選擇
  - 可以依據不同的語法單元移動, 例如分隔號, 函式區塊, 模組
  - 修改後縮排程式碼
  - 快速註解與取消註解
  - 還原與重做
  - 視窗分割與切換
  - 移動到行號
  - 依據字串, regular expression 搜尋並且允許同時修改所有的搜尋點
  - 顯示編譯錯誤
  - 執行專案測試
- 學習編輯器的 extension 與撰寫, 在需要時有能力客製化

Version Control

- 提示 28. `一定要使用版本控制`
  - 所有的東西都在版本控制之下
- **刻意練習**在舊電腦壞掉時, 能多快速的在新電腦上還原一切
  - 所有的設定, SSH key, 安裝的應用程式, ...
- 版本控制當作專案中心
  - 選擇一個中央儲存庫的系統並且良好的支援
  - 存取控制, 安全性
  - 好用的 UI
  - 命令列執行所有的操作, 可以自動化
  - 自動化建構與測試, CI 環境
  - Brach merge (pull request) 支援
  - 問題管理, issue tracking, 最好能整合 PR 或 Commit
  - 良好的報告, 提供類似 Kanban 的專案管理
  - 良好的團隊溝通, 一些 hook 支援各種類型的通知

Debug

- 提示 29. `解決問題, 而不是責備某人`
  - debug 只是在解決問題
- 提示 30. `不要慌`
  - 關閉自我防備的心理
- **總是試圖發現問題的根本原因, 而不僅僅是問題的表面現象**
- 從哪裡開始
  1. 確認能編譯的過並且沒有任何的錯誤訊息 (讓自動化工具先除錯)
  2. 可能需要與 bug 回報的使用者會面來蒐集更多資訊
  3. 嚴格的邊界測試與實際使用者模式測試
- 提示 31. `在修復程式之前先進行錯誤測試`
- 除錯策略
- **先撰寫能重現錯誤的測試**
- 提示 32. `請一定要讀那該死的錯誤訊息`
  - **閱讀錯誤訊息**
- 錯誤結果的 bug, 使用 **debugger** 來追蹤不正確的值的來源
- **使用 binary chop 來加速尋找崩潰的位置, 有問題的值集合, 有問題的版本**
- 以 **log** 或 **trace** 尋找與時間相關的 bug
  - 範例: 追蹤 resource leak 時, 在每次 open 與 close 地方加上 log
- 塑膠黃色小鴨
  - 試著解說程式碼給其他人聽, 透過解說必須以不同面向或更深入的思考程式碼
- 提示 33. `'select' 沒有壞掉`
  - 應該優先尋找可控範圍內的錯誤, 而非把錯誤歸咎於其他服務 (OS, library, framework, ...)
- 提示 34. `不要假設, 請去證明`
  - 不要假設某些程式是正確的, 而是要證明他是正確的才可信
- 對於驚嚇的 bug 要去進行優化
  - 下次如何更快速的找到 bug
  - 是否需要其他方法讓錯誤更早顯現, 例如各種 testing, function attributes check

操作文字

- 提示 35. `請學習一門文字操縱語言`
  - 例如 Python, Ruby, ...
- 可以輕易的處理文字相關的事情
- 例如格式之間的轉換, 搜尋, 修改, 測試

工程日誌

- 使用手寫的日誌
- 紀錄當下任何的事情
- 當寫滿後寫下日期範圍

---

### 第四章 - 務實的偏執

- 提示 36. `你無法寫出完美的軟體`

合約式設計

- Design by Contract (DBC), 由 **Eiffel** 此物件導向語言所發明
- 重點在於**紀錄合約**與**驗證合約**
- 針對方法或函式在**實作之前**先思考與定義合約
  - 合約定義所有成功與失敗的情況與處理
  - 簡單列舉輸入範圍, 邊界條件, 函式承諾的交付, 函式不承諾的交付
  - 除了程式語言直接的支援之外, 也可以將合約以**註解**或者**單元測試**的方式加入
- 前置條件 Precondition
  - 在呼叫時什麼東西必須是正確的, 違反時函式應該不被執行
  - **傳遞正確的資料是呼叫者的責任**
- 後置條件 Postcondition
  - 完成時的狀態
  - 函式的執行承諾
- 類別**不變量** Class invariant
  - 在類別中永遠必須符合的條件
- 函式與呼叫者之間的合約可以被解讀為
  - 呼叫者滿足所有前置條件, 函式在完成時保證所有後置條件與不變量成立
- **無論呼叫者或函式不能滿足合約時**
  - 應該會呼叫事先約定好的補救措施
  - **任何一方不能履行合約都是個錯誤**
- 提示 37. `用合約進行設計`
  - 重點在於**懶惰的**合約
  - 嚴格要求能接受的東西, 並且盡可能少的執行承諾 (單一責任原則)
- 與防禦性程式設計的差別
  - 防禦性程式設計, **每個人**都進行資料驗證與檢查
  - 合約式設計, **由呼叫方保證輸入值的正確性** (更 DRY 的作法)
- **早期崩潰**
  - **盡早使程式崩潰並且回報更準確的問題資訊** 重要
  - 越早發現問題越容易除錯
- 語意**不變量** semantic invariant
  - 一種哲學合約 philosophical contract
  - **如果發現或找出固定的, 且永遠不可違反的需求, 應該把他清楚地列出來讓所有人知道**
  - 例如: 交易程式永遠不應該重複扣款
  - 清晰, 簡約, 明確的描述並且每個人都應該看得到且遵守

死程式不說謊

- 提示 38. `早期崩潰` 重要!
  - 當錯誤發生時, 直接讓他崩潰造成更小的損害
  - 延遲錯誤只會讓錯誤被傳遞, 擴大損害範圍與增加除錯的難度
- 盡可能地讓程式早點崩潰, 與其浪費時間進行防禦性程式設計, 直接讓他崩潰
- 崩潰的程式會由管理器 (supervisor) 管理, 階層的管理器會知道如何處理錯誤, 例如自動重開機, 自動重新啟動, ...

assertion 式程式設計

- 提示 39. `請使用 assertion 避免不可能發生的事`
- 以 assert 形式, 來**讓不可能發生的事情**現形
  - 必須與正常的錯誤處理區隔
- assert 的執行必須是**沒有副作用的**
  - 如果發生例外記得正確的處理
- 在 production 環境仍然要開著 assertion 的功能, 來捕捉實際可能遇到的錯誤
  - 如果遇到效能問題, 也只能關閉真的影響效能的 assert, 而非完全關閉
- **精心設計的 assertion 保護 production 環境能捕捉所有的失敗與相關訊息**
  - 讓 bug 發生時在第一時間最真實的被捕捉並且帶有相關資訊
  - 免除開發者要去重現模糊且難以複製的 bug

如何平衡資源

- 提示 40. `由取得資源的人負責釋放資源`
  - 去除資源管理造成的耦合
- 提示 41. `在小區域進行動作`
- 巢狀取得資源
  - 注意取得資源與釋放資源的順序要相反, 避免產生 leak
  - 當有多個位置取得同一資源時, 要注意 deadlock 的可能性
- 物件與例外處理
  - 把資源封裝在物件內部, 並且會在解構時釋放資源
  - 在遇到例外處理可能干擾資源釋放時特別好用 (如果物件超過 scope 時會自動被釋放)
- 如果使用 \*_try...catch...finally_ 模式處理時
  - **記得取得資源的語法應該放在 try 之外**, 避免在 finally 階段可能去釋放根本沒取得的資源
- **檢查平衡** 重要!
  - 務實的程式設計師不相信任何人包含自己
  - **對資源管理進行檢查**, 不管是高階或者低階的
  - 確保沒有 memory leak
- _補_, 理解所使用的程式語言的垃圾回收機制

不要跑得比您的車頭燈還快

- 提示 42. `每次總是只走一小步`
  - 小步小步走, 並且在走下一步之前**檢查回饋**和調整
  - 不僅僅限於程式設計
- 車頭燈的範圍代表**可控制的範圍**
  - 任何需要進行算命的範圍都是超過範圍的 (**需要猜測就代表超過範圍**)
  - 只為能看到的範圍負責
- 與其浪費精力在為不確定的未來設計, **還不如把程式設計的更容易替換**
  - 意味著高內聚, 低耦合, DRY, 更好的架構設計
- 提示 43. `避免猜測未來`
  - 記得黑天鵝
  - 很多時候, 您會覺得明天的情況大概和今天差不多, 但千萬別這樣想

---

### 第五章 - 彎曲或弄壞

- 應該盡一切努力撰寫盡可能寬鬆, 靈活的程式碼
  - 否則程式碼很快就會過時, 或太脆弱而無法修復

去耦合

- _補_, 耦合即知識!
- 提示 44. `去耦合化的程式碼比較好改`
- 耦合關係產生的症狀
  - 不相關的模組或函式庫之間古怪的依賴關係
  - 只對一個模組進行修改, 影響系統中不相關的模組和破壞系統中的東西
  - 害怕修改程式碼的開發人員, 因為他們不確定會受到什麼影響
  - 每個人都必須參加的會議, 因為沒有人確定誰會受到變化影響
- 方法呼叫鏈
- 提示 45. `直接命令, 不要詢問` 重要!
  - 減少參與的知識, 避免隱含的知識參與
  - 不應該根據物件內部狀態做出決策, 然後才更新該物件
  - **直接委派**
- 迪米特定律 the Law of Demeter, LoD, 一個類別裡的方法只能呼叫
  - 本身類別裡的其他實例方法
  - 方法本身的參數
  - 方法本身所建立的其他物件的方法
- 提示 46. `不要串連呼叫方法` 火車殘骸, 重要!
  - 避免使用超過一個 _._ 來存取
  - 以中繼變數取代連續的 _._
  - 為了使用串接必須回傳物件, 則該回傳物件變成一種額外的耦合
  - 把物件導向方式轉向函數式設計
  - 只有一個例外是該 API 非常穩定, 例如語言自帶的原生函式庫
- 撰寫程式碼時重用可能不是主要考慮, 但是在撰寫程式碼時**習慣性思考重用**會帶來更乾淨的介面, 更去耦合的程式
- 提示 47. `避免全域資料` global data
  - 包含 singleton object 單體模式
  - 任何可變的外部資源都屬於全域資料, (資料庫, 檔案系統, 服務 API)
- 提示 48. `如果非得當成全域資料使用, 請確保將它用 API 包裝起來` 重要!
  - 外部資源, 全域資料, 始終包裝在受自己控制的程式碼之後, 以自製介面隔離
- 繼承增加耦合
- 請讓程式碼保持害羞, 只讓它處理它直接負責的事情, 有助於保持程式去耦合, 將使它們更易於修改

行走江湖

- 今天我們更期望電腦融入我們的世界, 而不是我們去配合電腦的限制
- 事件 event
  - 一個事件代表有一份可用的資訊
  - Event based 設計讓使用者更具互動性, 應用程式也更好使用資源
- 事件無處不在, 圍繞著事件撰寫的程式碼比對應的線性程式碼比起來更快速且更去耦合
- **協助實踐 event 的四種策略** 重要!
  1. Finite State Machine 有限狀態機
  1. Observer Pattern 觀察者模式
  1. Publish/Subscribe, pubsub 發佈/訂閱
  1. Reactive Programming 回應式程式設計與 Stream 串流
- **Finite State Machine 有限狀態機**
  - 實用的 FSM 並且應該可以簡單的快速實作出來
  - 狀態機基本上就只是**處理事件的規範**
  - 分成狀態 (state), 目前狀態 (current state), 與每個狀態可以處理的 event 與狀態轉換 (transition), 並且可以包含觸發的 (action)
  - **找機會練習**
- **Observer Pattern 觀察者模式**
  - Observable 觀察物管理一組 callback list 在事件觸發時迭代呼叫
  - 因為需要註冊 (register) 因此也有一定程度的耦合
  - 在典型的實作中, 是同步的走訪且呼叫 callback function 因此可能因為阻塞產生效能瓶頸
- **Publish/Subscribe 發佈/訂閱**
  - 基本上是一個 message passage 系統
  - 是 Observer Pattern 的通用版並且解決 Observer Pattern 的兩個問題 (耦合與效能)
  - 分成 Publisher, Subscriber, Channel
  - 以增加 Channel 作為中間層 (共用介面) 來解決 Observer Pattern 耦合問題
  - Channel 可以是 library, process, distributed system 這些細節應該隱藏在介面之下
  - 通常不會自行實作, 而是採用雲端供應商的服務或者語言函式庫實現
  - 對於非同步事件處理是非常好的去耦合模式
  - 缺點是很難追蹤工作流程
- **Reactive Programming 回應式程式設計與 Stream 串流**
  - Reactive 當一個值變化時, 使用到的其他值也會一同變化
  - 各語言有分別的 Reactive library 可以使用, 例如 RxJS, RxJava, ...
  - Stream 視為 event 的集合, 因此可以進行集合操作 operators
  - 可以提供平行處理能力
  - Event stream 是非同步集合
  - 變得不需要管理時間, 讓非同步集合與同步集合共用相同的 API

轉換式程式設計 (函數式)

- 以思考資料的轉換, 資料的輸入與輸出產生乾淨的介面
- 提示 49. `撰寫程式的重點在程式碼, 但程式本身的重點卻是資料`
- 從頂層一步一步的找出**轉換**, 從需求開始確保輸入與輸出是什麼, 一種 top-down 的設計方式
- 有 _pipe_ 的程式語言, 把上一層的輸出值自動變成下一層的輸入值
- 在沒有支援 _pipe_ 的程式語言可以使用中繼變數取代
- 提示 50. `不要囤積狀態, 逕行傳遞出去`
  - 物件導向式習慣隱藏封裝資料, 然後以物件傳遞, 這樣會造成與物件耦合
  - 把資料視為河流 (Data Stream) 在函式之中流動
  - 物件導向式轉向函數式
- 錯誤處理
  - 比起傳遞原始的值之外, 在函數式中通常使用 wrapper 包裝, 例如 Haskell _Maybe_, Scala _Option_
  - wrapper 包裝中擁有兩種狀態 1. 成功 + 值, 2. 失敗 + 錯誤訊息
- 錯誤處理分成兩種類型, 函式內部處理, 函式外部處理
  - 函式內部處理, 每個 function 會有同名異式, functional 中可以使用 pattern matching 實現, 分別處理成功與失敗的狀態
  - 函式外部處理, 以通用的 function 包裹每個執行函式, 在通用的函式中處理遇到失敗狀態的呼叫
- **練習**

繼承稅

- 繼承就是一種耦合, 而且是強大的影響
- 提示 51. `不要付繼承稅` 重要!
- 取決於需求, 以不同的技術實現
- 提示 52. `請選用介面來表達多型關係`
- 共享型別 (多型 polymorphism)
  - 以 **interface**, **protocol** 實現, 名稱取決於使用的語言
  - 重點在於: 單純的結構介面, 不包含任何實作
  - 強大之處在於它們可以被當成型別使用
- 提示 53. `使用委派: 擁有什麼不如身為什麼`
- 加入功能
  - 使用 delegate (委派) 來增加需要的功能而不是使用繼承
- 提示 54. `請使用 mixin 共享功能`
- 共用方法
  - 以 **mixin**, **trait**, **categorie**, **protocol** **extensions** 名稱取決於使用的語言
  - 重點在於: 合併現有內容與新內容

設定

- 如果應用程式有些值會因為執行而改變時, 應該變成外部設定
- 找出知道不得不修改的東西, 並且可以在程式碼之外表達的東西
- 提示 55. `使用外部設定, 以參數化您的應用程式`
- **設定值應該改變執行期的行為但是不需要重新建置**
- configuration 設定分成兩種類型
- 靜態設定 static
  - 以一般檔案 YAML, JSON 之類的存在
  - 以資料庫的方式存在 (適用於有結構的, 並且有機會被外部人員改變)
  - **記得設定值, 應該被簡單的 API 封裝起來, 避免程式主體混入不必要的耦合**
- 設定如一種服務 dynamic, Configuration as a Service
  - 設定做為一種服務存在, 以 API 來取得
  - 適合共用設定, **動態設定**
  - 避免應用程式需要重新啟動

---

### 第六章 - 並行

- concurrency, 好像同時執行一樣 (軟體實現)
  - 通常以 thread, fiber, process 實現
- parallelism, 真的同時執行 (硬體實現)
  - 通常需要配合硬體實現, 多核心的 CPU, 多 CPU 的電腦, 或電腦叢集

打破時間耦合 temporal coupling

- 提早思考時間的耦合, 關於 concurrency 與 order 順序
- 為了實現 concurrency 必須去掉時間或順序的耦合
- **刻意尋找並行機會, 找出什麼可以同時發生, 什麼必須嚴格照順序執行**
- 提示 56. `分析工作流程以提升並行`

不要共用狀態 shared state

- 提示 57. `共用狀態是不行的`
  - 任何可共用的可變資源都會產生並行問題, 例如: 檔案, 資料庫, 外部服務, ...
- Atomic 原子性更新
- 以 **semaphore**, **mutex**, **monitor** 實現資源的控制
  - 然而, 儘管如此撰寫正確且可閱讀性佳的並行程式仍然是困難的
- 原子性更新的實現位置
  - 由使用者控制 (不好)
  - 由函式集中控制 (小心各種錯誤處理與正確的使用)
- 提示 58. `隨機發生的錯誤, 通常是個並行問題`

參與者與程序

- **Actor Model** 用來設計平行程式用的一種模式
- Actor
  - 每個參與者都是一個虛擬獨立的 CPU 管理自己私有的記憶體空間, 私有狀態 (其他參與者不允許讀取),
  - 每個參與者都有一個信箱, 用來對外溝通
  - 參與者一次只處理一個信件工作並且當工作處理完才會查看信箱取得下一個工作
- Process 概念上是更通用的虛擬 CPU, 與 OS 上的 Process 不同
- 參與者只能是並行的
- 資料是單向的
- 資訊存在信件上與每個參與者自己私有的狀態中
- 提示 59. `使用參與者模型可做到不共用狀態的並行工作` 重要!
- Actor Model 不用明確指定並行
  - 不需要額外撰寫並行運算管理程式碼
  - 沒有任何共用狀態
  - 可以在單核心, 多核心, 多網路任何平台上運作
- **Erlang** 程式語言的 Process 模式非常類似於 Actor Model
- _補_, 考慮學習 **Erlang** 或在任何平台上練習 Actor Model 例如 JavaScript **Nact** library

黑板

- **Blackboard Pattern 黑板模式**
- 任何人在任何時候可以在黑板上留下新的資訊
- 所有人都可以通過黑板上的資訊做推理來達到目標
- 提示 60. `使用黑板協調工作流程`
- **可以以 log based Message Queue 服務作為黑板平台**
- 使用 **Actor Model**, **Blackboard Pattern**, **Microservice** 架構來解耦合時會產生難以追蹤流程
  - 可以使用在啟動時建立 trace id 的方式來傳遞且追蹤
  - 此類系統在部屬與管理較麻煩, 但是好處是讓系統變得更細緻, 更解耦合並且可以動態更新

---

### 第七章 - 當您寫程式時

聆聽您的蜥蜴腦

- 首先注意到自己的直覺正在發生, 然後找出其發生原因
- 恐懼空白頁
- 提示 61. `聆聽內在的蜥蜴腦` 重要! (傾聽直覺, 查明真相)
  1. 停止現在正在進行的事情, 給大腦一點自己的時間與空間 (利用大腦的自行推理產生的直覺)
  2. 把問題外部化, 畫個圖, 講給其他人聽, 講給黃色小鴨聽 (讓大腦利用不同的方式刺激)
  3. 以 Prototype 實作 (以丟棄式的做法讓大腦放心)
- 做些 Prototype 設計, 探索任何想要探索的方面
  - 例如新的 framework 是如何運作的
  - 例如新的演算法的 edge cases 行為
  - 例如不同類型的 UI 介面
- 把正在處理的現成程式碼藏起來, 重新製作一個類似的 Prototype
  1. 以便利貼寫下我正在製作 Prototype 貼在螢幕旁邊 (有疑惑時重新看一下這張便利貼)
  2. 提醒自己 Prototype 註定會失敗, 並且被丟棄, 失敗也沒關係
  3. 在空白編輯器裡寫下一行註解, 描述目前想學習或做什麼
  4. 開始撰寫 Prototype 程式碼
- 實驗結束後, 散步, 休息, 談話一下
- 已經實驗結束知道, 問題點在哪了, 因此**刪除所有的 Prototype, 扔掉便利貼, 開始撰寫新的程式碼**
- 不只是您的程式碼 (在其他人寫的程式碼上工作時)
  - 努力的閱讀他人的程式碼並且做筆記
  - 做個實驗. 試著找出程式碼中奇怪的做法和規律模式, 去思考為什麼他們會這樣撰寫 (學習到其他人的思考模式與新的做法)
- 傾聽自己的直覺是重要的事情!
  - 不只在程式設計時
  - 感覺設計不對, 需求感到困難, 都應該停下來進行分析

靠巧合寫程式

- 應該避免依靠巧合撰寫程式, 而是**蓄意的設計程式**
- 靠巧合寫程式
  - **一開始就不知道為什麼它能工作**
- 對於呼叫的函式只依賴它寫在文件上的行為, 如果沒有文件, 應該把假設寫下來
- 對外要給其他人呼叫的函式應該是良好模組化的, 實作隱藏在小的, 有說明文件的介面後面 (合約式設計)
- **不要假設, 要證明**
- 環境造成的意外, 小心模組相依在外部的假設上
  - 例如: 使用者必須懂英文, 擁有某些專業訓練
  - 例如: 伺服器時間必須是準的, 檔案必需可寫入, 依賴網路的速度
- 提示 62. `不要依賴巧合寫程式`
- 所有階段中大家都在頭腦中有各種假設, 但是假設很少被記錄下來, 並且不同的人有不同的假設, **不以既定事實為基礎的假設是所有專案的禍根**
- **如何謹慎的設計程式** 重要!
  - 時時刻刻注意自己在做什麼
  - 能像更初級的程式設計師仔細解釋程式碼嗎 (確定自己知道為什麼)
  - 不要在黑暗中撰寫程式, 使用沒有完全掌握的功能或不了解的技術 (不確定它為什麼能正常工作, 就不會知道它為什麼失敗)
  - 請從做計劃開始, 先思考, 寫下來
  - 只依賴可靠的東西, 不要依賴假設 (如果不知道是否可靠, 那就代表不可靠)
  - 記錄自已的假設, 以合約式設計, 釐清假設並且方便溝通
  - 不只測試程式碼還要測試假設, 不要猜測, 實際去證明
  - 優先考慮力氣要花在哪? 把時間花在重要的地方
  - 不要成為歷史的奴隸, 不要讓現有的程式碼支配未來的程式碼, 當程式碼不再適合時, 所有的程式碼都是可替換的

演算法速度

- 估計演算法速度, Big-O
- 提示 63. `估計您演算法大約的 Big-O 等級`
- 提示 64. `測試您的估計`
  - 可以配合 code profiler 側錄執行次數並且輸出成圖表
- **最快的不一定是最好的** 重要!
  - 避免過早最佳化 premature optimization
  - 只有在演算法效能成為瓶頸時, 才進行優化
  - 過早最佳化的程式碼, 可能更複雜, 更難撰寫, 更難理解, 更容易有 bug

重構

- 程式碼不像是建築, 更像是草坪
  - 需要時常的維護, 因應狀態而調整
- Refactoring (重構) 是 Restructuring (重建) 的子集
- 重構的定義
  - 重組現有程式碼主體, 改變其內部結構而不改變其外部行為的嚴格技術
  - 重構是嚴格的, 不是自由的
  - 外部行為不變, 因此不會添加新功能
- 重構是一日復一日的維護工作, 以**低風險的小步驟進行 (並不是針對程式碼自由且大型的重寫)**
- 重構是針對性, 精準的工作, **目標是維持程式碼易於修改**, 不要讓人害怕去修改程式碼
- 任何時候覺得是錯的時, 請不要猶豫去修改, 最適合重構的時機就是**現在**
  - 重複: 發現違反 DRY 原則時
  - 非正交設計: 發現可以把正交性做得更好得時候
  - 過時的知識: 對問題更加理解, 事情, 需求變化時
  - 使用: 系統在被真正的人使用時, 注意到更重要的功能
  - 效能: 功能從系統的一個區域移動到另外一個區域以提升效能
  - 通過測試時: TDD 通過測試時, 是一個很好的機會來深入研究並且整理剛撰寫的程式碼
- 提示 65. `早期重構, 更常重構` 重要!
  - 不要因為時間壓力而延遲重構, 趁問題還小就做
  - **不應該需要用一個星期來重構, 這代表算是大規模重寫**, 這種規模的重寫需要安排在時間表上, 必須讓受影響的使用者知道這個計畫與影響範圍
- 如何重構, 慢慢的, 慎重的, 仔細地進行
  - 不要同時重構並且添加新功能
  - 重構前必須有良好的測試, 並且盡可能頻繁地執行測試
  - **採用簡短且慎重的步驟**, 每次都做小小的步驟然後執行測試, 避免未來冗長的除錯
- 如果不得不做的比重構更多, 而且最終需要修改外部行為或介面, 則必須破壞架構
  - 必須重寫時, 就應該盡早加入時間表, 修復它
  - 控制痛苦
  - 如果現在很疼, 放在一邊不管, 未來只會更疼

測試對程式碼的意義

- 提示 66. `測試的目的不是為了要找出 bug`
  - **測試的主要好處發生在你思考和撰寫測試時**
- 以測試驅動程式碼撰寫 (代表以思考驅動)
- 提示 67. `測試程式是您程式碼的第一個使用者`
  - 思考測試使程式碼減少耦合, 增加靈活性, 思考測試時, 我們以外部看待這個程式碼, 像是使用程式碼的人
  - 緊密耦合的程式是很難被測試的東西, 因此變得**可測試的同時, 也減少了耦合**
  - **在撰寫程式之前, 就先考慮測試 edge cases, 測試錯誤條件**
- 測試驅動開發 test-driven development, test-first development, TDD 紅綠燈
  1. 決定要添加的小功能
  2. 撰寫一個測試, 該功能完成後會通過的測試
  3. 執行**所有**測試, 確保只有剛撰寫的測試失敗
  4. 實作通過該測試**最少的**程式碼 (baby step)
  5. 通過測試後, 重構程式碼, **改進剛撰寫的程式碼**
- 避免成為 TDD 的奴隸
  - 不要追求 100% 的測試覆蓋率
  - 不要撰寫重複的測試 (多餘的測試)
  - 錯誤的從底層開始設計 (過於專注細節而忽略了大局, 反而引導到錯誤的方向)
- 由上而下, 由下而上, **開發忽略最重要的部分是: 我們不知道一開始要做什麼**
  - **重點在於不知道要什麼就開始寫程式, 不管是不是使用 TDD 的方式, 都會引導到錯誤的方向**
  - 心理必須有個目的地, 否則只是一直在兜圈而已
- 提示 68. `請用點到點的方式建構, 而不是下而上或下而上`
  - 堅信建構軟體的唯一方式是逐漸補完的
  - 建立多個點到點的小功能, 一邊前進, 一邊了解問題, 繼續應用所學到的東西撰寫程式, **每一步都讓客戶參與, 讓他們來領導這個過程**
- 單元測試 Unit Test
  - **依合約進行測試**, 撰寫 test case 來保證符合合約, 想測試出在廣泛的測試案例與 edge cases 下, 模組有提供它承諾的功能
- 避免製造時間炸彈 (某個被忽略的東西, 在專案後期緊迫時刻爆炸), 強調針對合約的測試來避免下游災難
- 提示 69. `為測試而設計`
- 臨時測試
  - 手動的除錯, 例如 console.log, ...
  - 在進行結束後都應該撰寫成正式的測試, 出現一次錯誤, 就可能有第二次錯誤
- 建構一個測試通道
  - 部屬到線上去之後, 有專用的測試通道
  - 例如: 被標準化的 log 訊息 (有規則的, 一致的, 可被自動分析的)
  - 例如: feature switch 特定使用者開啟額外的診斷功能
- 測試的文化
  - 撰寫的所有軟體終將被測試, 不管是由你, 你的團隊, 最終的使用者
  - 提前徹底的撰寫測試, 大大的降低維護成本
  - **所有的測試在任何時候都應該能通過**, 忽視任何的測試失敗, 就會造成破窗
- 撰寫測試的三個選擇:
  - 先寫測試
  - 撰寫期間寫測試
  - 永遠不測試
- 測試程式碼就等同於產品程式碼, 要符合程式碼品質的要求
  - 保持去耦合性
  - 保持簡潔性
  - 保持健壯性 (robust), 不要依賴不可靠的東西
- 提示 70. `請測試你的軟體, 否則將由您的使用者進行測試`
  - 測試是程式設計的一部分, 而且是程式設計師的工作
  - 測試, 設計, 撰寫程式碼都是程式設計

以屬性為基礎的測試

- Property-based Test, **隨機且自動化的測試集, 來驗證 property**
- Property: 合約 + 程式碼不變數
- 在遇到測試失敗時, 要把該隨機測試值變成正式的單元測試
- 提示 71. `使用以屬性為基礎的測試驗證您的假設`
  - 讓我們使用不變數與合約的角度來思考程式碼
  - 去想什麼不能改變, 什麼必須是真實的
  - 以屬性為基礎的測試來補足單元測試的不足

待在安全的地方 (security)

- 安全基本原則
  - 最小化攻擊表面積
  - 最小權限原則
  - 安全預設值
  - 對敏感性資料進行加密
  - 維護安全更新
- 提示 72. `保持簡單, 並且最小化攻擊表面積`
- 最小化攻擊表面積
  - **攻擊表面積**是指攻擊者可以**輸入資料, 取得資料, 呼叫服務執行的所有存取點加總**
  - 程式碼複雜性招來攻擊, (程式碼越簡單越好, 更少的程式碼代表更少的 bug, 更少的漏洞)
  - 輸入的資料招來攻擊, (永遠不要信任來自外部的資料), 一定要進行消毒
  - 未經身分認證的服務招來攻擊, (不需要身分認證就能呼叫的服務就是給 DoS 製造攻擊機會)
  - 經過身分認證的服務招來攻擊, (請將授權使用者的數量保持在最小數量), 淘汰不使用, 舊的, 過時的使用者與服務
  - 輸出資料招來攻擊, (請截斷或混淆具有潛在的危險資訊), 不應該輸出任何可能被用於攻擊的資訊
  - 除錯資訊招來攻擊, 確保測試通道和異常報告都是受到保護的, 而非任何人可得
- 最小權限原則
  - 使用**最小的權限**, 盡快在**最短的時間**內離開
  - 如果高權限是必須的, 就應該只能進行最少的工作, 並且盡快放棄權限來降低風險
  - **每個程式和系統的每個授權使用者, 都應該使用完成作業所需的最少數量授權進行操作**
  - 切分更細緻的權限層級
- 安全預設值
  - **預設值應該是最安全的值, 而非最方便的值**
- 對敏感性資料進行加密
  - 不要將任何敏感性資料以明碼儲存, 加密提供了額外的安全性
- 提示 73. `盡早套用安全更新`
- 維護安全更新
  - 越早進行越好
  - 不要讓以公開的 bug 持續被開採
- **密碼的安全建議**
  - **目的在於鼓勵使用者使用較長的, 高度亂度的隨機密碼**
  - 不要限制密碼在 64 個字元以內, NIST 建議以 256 字元為最大長度
  - 不要截斷使用者所選擇的密碼
  - 不要限制使用特殊字元
  - 不要向未經身分認證的使用者提供密碼提示
  - 不要禁用貼上功能, 或其他瀏覽器密碼管理工具
  - 不要去強加組合規則, 不要對密碼規則做任何限制
  - 不要任意要求使用者在一段時間後修改密碼, (只有在有正當理由時才允許, 例如: 已經出現漏洞)
- **不要自己做加密演算法**
  - 只依賴可靠的東西, 經過良好審查, 徹底檢查, 維護良好, 經常更新, 最好是開源的
- **仔細研究**網站與應用程式其他與安全性相關的功能
  - 例如, 身分驗證機制
- 採取務實的做法, 讓其他人來操心加密這件事, 並使用協力廠商身分驗證提供者 (第三方身分驗證服務)
- 請多保重!

命名

- **我創造這個的動機是什麼**
- 不斷的尋找方法來闡明你的意思, 將使你在寫程式碼時能更容易理解你的程式碼
- 尊重文化
  - 尊重語言社群的慣例
  - 先了解社群期望看到什麼樣的名稱
- 一致性
  - 每個專案都有自己的詞彙表: 記錄對團隊有特殊意義的術語
  - 重要的是, 團隊中的每個人都要知道這些詞的意思, 並始終如一的使用他們
  - 鼓勵大量的交流, 頻繁的交換責任分工, 術語就會傳播開來 (knowledge sharing)
  - **使用專案術語表**
- 重新命名
  - 當發現一個問題時, 立即修復它
  - **小心且立即修正誤導性名字**
- 提示 74. `請好好的命名; 在有需要時重新命名` 重要!
  - 如果無法立即修復重新命名問題, 就必須先處理 Ease to Change 問題, 務必讓重新命名變得容易且經常重新命名

---

### 第八章 - 專案啟動前

需求坑

- 提示 75. `沒有人確切的知道自己想要什麼`
- 提示 76. `程式設計師幫助人們了解需求`
- 需求探索是一個持續發生的流程
- 提示 77. `需求是從回饋的循環中了解的`
  - 談話, 學習反饋
  - 整個專案的一切活動都是為需求探索的一部分, (包含撰寫程式碼)
  - 因此我們喜歡更短的週期, 更快速的取得客戶的直接反饋, 確保我們工作在正確的方向上
- 提示 78. `和使用者一起工作, 讓您向使用者般思考`
- 站在客戶的立場思考
  - 就是成為客戶!
  - 直接與程式碼客戶一起工作一週, 執行他們的工作或者旁聽一週
  - 收集反饋也是開始與客戶建立融洽關係的時候, 了解他們對系統的期望與期待
- 提示 79. `政策就是描述性資料`
- 小心的區分需求與政策
  - 商業政策是會修改變動的
  - 把政策作為系統需要支援變動的事物
- **工具的成功要歸功於使用它們的人**
  - 客戶會說它正是我**想要的**東西, 而不是我**想像出來的**那個東西
- 紀錄需求
- **最好的需求文件就是可工作的程式碼**
- 不需要龐大且詳細的需求文件, 但是需求應該被記錄下來
- **以 user story 的方式記錄需求**, 配合 kanban 移動且紀錄 user story 的工作階段
  - user story 應該是簡短敘述的索引卡
  - 正因為簡短敘述, 因此鼓勵客戶與開發人員互動釐清問題, 在開發過程中密切頻繁的反饋
- 過度指定規格
  - 好的需求是抽象的
  - 最簡單, 最能準確反映業務需求的敘述句是最好的
  - 必需掌握背後的語意不變數
  - **需求不是架構, 需求不是設計, 也不是使用者介面, 需求就是需求**
- **很多專案的失敗都貴就於專案範圍的增加**, 功能膨脹 feature bloat, creeping featurism, requirements creep
  - **與客戶一起工作, 不斷反饋迭代中, 讓他們直接體會額外多增加一個功能會造成的專案影響, 因為客戶也是工作群組中的一部分**
- 提示 80. `請使用專案術語表` 重要!
  - 所有專案的參與者, 開發人員, 客戶, 都應該使用一致性的術語

解開不可能的謎題

- 尋找解決方案時, 重要的秘訣是**識別出真實的限制, 而非想像中的限制**, 只有真實的限制是**必須**遵守的
- 提示 81. `不是跳出框框思考, 而是找到框框`
  - 解謎的關鍵在於**識別出實際所受到的限制, 並且找到實際所擁有的自由度, 然後在這些自由度裡找到答案**
  - 範例: React virtual DOM tree diff 演算法複雜度
- 面臨一個棘手的問題時
  - 應該一一列出所有可能的途徑, 不要忽略任何東西, 無論他們多無用或愚蠢, 然後掃描整個清單解釋為什麼不能選擇這個選項, 並且**要證明**他們不能
- 自由度
  - 當感到困難無助時, 應該暫時做點別的事情, 讓自己忽視這個問題, **留給大腦一點時間自行推理**
  - 簡單來說, 容易注意力分散的人在解決複雜問題時比有意識的人做得更好
- 跟黃色小鴨對話, 跟其他人對話嘗試問點問題
  - 為什麼要解決這個問題? 解決它有什麼好處? 是否與 edge cases 有關? 能消除它們嗎? 若有一個更簡單的類似問題, 有辦法解決嗎?
- 機會是留給準備好的人
  - 要讓大腦自行推理, 需要累積足夠的養分
  - 無意識的大腦需要大量的原料, 過去的經驗有助於得到一個答案
  - 使用工程日誌紀錄, 是提供大腦原料的好方式, 讓它知道什麼是正確的什麼是不正確的

一起工作

- 提示 82. `不要隻身進入程式碼的世界`
- Pair Programming, Mob Programming
  - 一個人寫出程式碼, 由另一個人或多個團隊成員一起討論, 思考, 解決問題
  - 一起寫程式勝過於無窮無盡的會議
  - 是一種緊密合作的 live coding
- **協作時的小技巧** 重要!
  - 要建立的是程式碼, 而不是自負, 無關誰比較聰明
  - 從一個小的規模開始, 4-5 人的小暴民團, 或者 pair programming 非常短的時間協作
  - 批評程式碼, 而不是人. (對事不對人), 讓我們看這些程式碼, 比你錯了更好
  - 傾聽並試圖理解他人的觀點, 觀點不同不是錯誤
  - 進行頻繁的回顧, 為下一次做好準備
- **每種開發風格作法, 都有規則, 建議, 指導方針, 請好好學習後再開始實行**, (pair programming, mob programming 有各自的實務規則建議)
  - 閱讀教科書, 其他人的經驗分享, 感受一下可能遇到的優勢與缺點
  - 從簡單的練習開始, 不是一開始就進行最難的程式設計
- Conway 法則
  - 負責設計系統的組織設計出來的東西, 會是這些組織溝通結構的副本
  - 即怎麼樣的組織就會產生什麼樣的系統
  - **故意按希望程式碼的樣子來組織團隊**, 更重要的是**把使用者包含在團隊裡**

敏捷的本質

- agile 是一個形容詞, 不是一個名詞, 更不是一種作法, 流程
- 提示 83. `Agile 不是一個名詞; agile 是您做事的方式`
- **請記住敏捷宣言與匠藝宣言裡的價值觀**
  - **個體與個體間的互動**勝過流程與工具
  - **能正常工作的軟體**勝過複雜完整的文件
  - **客戶協作**勝過合約談判
  - **回應變化**勝過遵循計畫
- 敏捷宣言裡都是**關於收集與回應反饋**
- 不可能有所謂的敏捷流程
  - **任何固定的流程就是不敏捷的**
  - **敏捷關於的是對變化的回應**
  - 一切歸咎於**如何處理不確定性**, 敏捷宣言中的建議是透過收集反饋然後採取行動來達成
- **我們該怎麼做?** 重要!
  1. 找到自己目前的處境
  2. 朝向想要的方向邁進**最小**, **最有意義的**一步
  3. 重新評估當前的處境, 修復我們所破壞的一切
- 重複這些步驟直到完成
  - 這樣的流程可以套用在不同層次的問題上
  - 例如: 程式設計時, 與客戶釐清需求時, 審查專案流程是否敏捷時
- **好的設計容易改變**

---

### 第九章 - 務實的專案

- 專案不只一個人時, 建立一些基本規則, 相應的分配專案一部分的工作量
- 軟體發展方法論的目的是幫助人們一起工作

務實的團隊

- 50 個人不是一個團隊, 已經是一個部落了,
- 成員經常被分配到其他工作, 並且沒有人認識彼此, 這也不是一個團隊
- **團隊是一個小的, 最穩定的實體**
- **一個務實的團隊很小, 只有 10-12 個人, 會員很少加入或退出, 每個人都互相十分了解, 互相信任, 互相依賴. (agile team)**
- 提示 84. `請維護一個小型, 穩定的團隊`
- **不容許破窗**
  - 品質是一個團隊問題, 團隊**所有人**都應該為品質負責
  - 品質必定是來自於**所有**團隊成員的個人貢獻, 品質內建在這些貢獻之中, 不是被硬綁上去的
- **煮青蛙**
  - 請鼓勵**每個人積極監控環境的變化**
  - 保持清醒, 意識到專案範圍的擴大, 時間尺度的縮短, 額外的功能, ...
  - 環顧四週, 注意專案中重大變化, 清楚知道其他人的狀態
- **調整您的知識組合**
  - **如果團隊認真看待改進和創新, 就應該排入工作裡**
  - **有空的時候會做代表永遠不會做**
  - 舊系統的維護
  - 處理回應和改良
  - 新技術實驗
  - 學習和技術加強
- 提示 85. `把工作排下去, 讓它執行`
- **團隊溝通**
  - 一個團隊中的開發人員必須互相溝通
  - 優秀的專案團隊, 有其獨特的個性, 人們期待與他們見面, 團隊使用一致的術語
- **建立一個品牌**, 幫助團隊進行整體溝通的技巧
  - 給專案, 團隊一個名字, 一個標誌, 建立團隊一個身分
- **不要讓重複發生在自己身上** DRY
  - 成員之間重複的工作會造成浪費並且產生維護的惡夢
  - **良好的溝通**是避免這些問題的關鍵, 好的溝通意味著**立即**, **無摩擦** 重要!
  - 應該能向團隊成員提出問題, 並且或多或少的**即時答覆**
  - 要等待一週的會議才能提問題或分享狀態, 會產生很多摩擦
  - **無摩擦**代表著**提問題, 分享進度, 你的問題, 你的見解和學習, 時刻注意你的隊友在做什麼, 這些都很容易且不需要什麼儀式** 重要!!!
  - 保持清醒, 保持 DRY
- 提示 86. `請組織具有完整功能的團隊`
- **團隊曳光彈**
  - 提供角色, 頭銜, 分割部門, 分割團隊, 只會引入閘門, 交辦, 會拖慢整個部屬的流程, Lean 中把這些稱之為浪費
  - **非常快速的實作非常小的功能, 並且貫穿整個系統, 立即與團隊溝通和交付情況的反饋**
  - 以點到點, 漸增的, 迭代式建構程式碼
- **自動化** 重要!
  - **確保一致性和準確性**的好方法是將團隊所作的**一切自動化**
  - 例如自動化所有的格式, 自動化測試, 自動化部屬
- 知道何時收手
  - 團隊是由**個人**組成的, 賦予每個成員用他們自己的方式發光的能力, 給予足夠的支援並確保專案交付價值
- _補_, 閱讀人月神話 The Mythical Man Month, Frederick Brooks

不要切開椰子

- 每個成功公司在軟體發展和管理上都有自己獨特的**理解**
- 仿效特定人造物, 表面結構, 策略, 流程, 方法是不夠的
- 提示 87. `用有效的開發方法, 不要用流行的開發方法`
  - 試驗想法, 保留那些看起來效果不錯的, 汰除其他任何東西
  - 時時刻刻的轉型, 再次改變作法
  - **Agile 精神才是成功的祕訣**, 適應變化
- 照本宣科的採用作法是最不 Agile 的
- 從任何方法中獲得最好的部分, 並且進行調整後使用
- 重要的是精神, 而不是流程方法
- 目的是 Agile
- Scrum, Lean, Kanban, XP, 只是各家為了實現 Agile 所嘗試使用的方法, 並不代表是最適合的
- 真正的目的
  - 目標不是使用 SCRUM, 使用敏捷的開發方法
  - **目標是能夠交付可工作的軟體, 這些軟體能在短時間內提供使用者新功能**
  - 目標是朝向**當下交付**, 不是幾週, 幾個月, 幾年
- 提示 88. `當使用者有需求時交付`
  - 只有當使用者需要時, 這樣做在業務上有意義時, 才交付產品
- 重要的是**快速適應, 避免任何的僵化**

務實的上手工具

- **專案堅實的基礎在於 1. 版本控制, 2. 無情的測試, 3. 完全自動化**
- **所有重複的工作都必須是自動化的, 能夠複製到任何有能力執行的機器工作**
- 確保一致性與可重複性, 任何參與手動行為的事情都不是
- **版本控制**
  - 所有的東西都至於版本控制之下, CICD, IaC
  - 部屬設定也在版本控制之下, 能夠自動發布到 production
  - **版本控制驅動建構和發布流程**, version control trigger CI/CD
- 提示 89. `請使用版本控制去驅動建構, 測試和發佈` 重要!
- **無情且持續的迴歸測試**
  - **我們被驅動著要尋找當下的 bug, 所以不必忍受別人在以後發現我們 bug 的恥辱**
- 提示 90. `早期測試, 更常測試, 自動的測試`
  - **好的專案, 測試程式碼可能比產出的程式碼更多**
  - 從長遠來看, 這些成本最終會便宜的多
- 提示 91. `在所有的測試通過之後, 程式碼才算完成`
- **自動建構程式會執行所有可用的測試 CI 流程**
  - 以 "實際測試" 當作目標
  - 任何測試環境與實際環境的差異都是 bug 孳生的地方
  - CI 測試包含但不限於單元測試, 整合測試, 確認和驗證, 效能測試, 特殊專案會有更多特殊的測試
- **單元測試 unit test**
  - 各模組單獨可執行的測試, 必須能獨立運作
- **整合測試 integration test**
  - 整合常常是系統中最大的 bug 來源
  - 證明子系統運作的良好, 彼此配合良好
  - 整合測試是從單元測試擴展出來的, 只是在測試整個子系統如何履行它們的合約
- **確認和驗證, 使用者驗證**
  - 這個功能是否滿足使用者需求了呢?
  - 錯誤的系統縱使沒有 bug 也是無用的
  - 以 end-to-end test 實現
- **效能測試**
  - 確保軟體是否滿足現實世界條件下的效能要求
  - 預期的 qps, 連線數, transaction 數量
- **測試測試程式**
  - 當撰寫了一個測試來捕捉特定的 bug 時, 請故意製造該 bug 並且確保測試能回報問題
  - 在撰寫測試時, 請確保會正確的發出警報
- 提示 92. `以刻意破壞來測試你的測試程式`
  - 在原始碼創建一個單獨的分支, 有目的的引入 bug, 來驗證是否捕捉的到
  - 可以使用 Netflix 的 Chaos Monkey 來搗亂服務和測試程式的彈性
- 徹底測試
  - 請不要期望看到 100% 覆蓋率, 並且覆蓋率也不代表了所有的狀態
- 提示 93. `請測試狀態覆蓋率, 而不是程式碼覆蓋率`
- **基於屬性的測試**
- 提示 94. `不讓同樣的 bug 出現第二次` 重要!!!
  - **在發現了一個 bug 的時候, 就必須撰寫對應的自動化測試**
  - 不要讓 bug 出現第二次
- **完全自動化**
- 提示 95. `請不要手動流程`
  - 請將一切都自動化
  - 過程中有任何手動步驟, 就無法自動部屬

取悅您的客戶 (重要!!!)

- 專案最終的目的
- 作為開發人員, 我們的目標是**取悅使用者**, 這就是唯一的意義
- 使用者要的不是程式碼
- **詢問使用者, 您如何知道這個專案被完成一個月或更久遠之後, 我們算是成功了?**
- **對業務價值的期望才是真正重要的東西, 而不僅僅是軟體專案本身, 軟體只是達到這些目的的一種手段**
- 已經發現專案背後潛在的價值期望後, **重要!**
  - 確保團隊的每個人都清楚這些期望
  - 在做決定時, 想想哪條路更接近這些期望
  - 依據期望嚴格分析使用者需求
  - 在執行專案的過程中, 繼續思考這些期望
- **對目標領域的知識增長**, 我們能對其他事情提出更好的建議, 從而解決潛在的業務問題
  - 因此開發人員應該頻繁的接觸不同的面向, 來獲得目標領域的知識
- 提示 96. `請取悅使用者, 不要只是發佈程式碼`
  - 想要取悅使用者, 應該與使用者建立一種關係, 積極地幫助他們解決問題, **問題解決者這才是務實的程式設計師的本質**.
  - 我們解決問題

傲慢與偏見

- 務實的程式設計師**不會逃避責任**, 樂於接受挑戰, 讓自已的專長廣為人知, 為自己的工作感到自豪
- 提示 97. `在您的產品上簽上自己的名字`
  - 如同工匠自豪地在自己的作品上簽名
- 匿名性會產生粗心, 錯誤, 懶惰, 和糟糕的程式碼
- **程式碼必需有負責的人, 但不用被個人佔有**, shared ownership
- **這是我寫的程式碼, 我為我的工作品質做擔保, 一個由專業人士撰寫的非常專業的工作**
- _補_, 我們是專業人士

---

### 第十章 - 後記

- 程式設計師和詩人一樣, 程式設計師在空中用空氣建立他的城堡, 透過發揮想像力創造
- 我們可以創造幾乎任何我們能想像得到的東西, 我們創造的東西可以改變世界
- **道德羅盤**
  - 我是否保護了使用者?
  - 我願意成為這個軟體的使用者嗎?
- 我是否已經盡了最大努力來保護這段程式碼的使用者免受傷害?
- 提示 98. `第一守則, 不要做傷害別人的事情`
- 提示 99. `不要讓卑鄙的人得逞`
- **想像一下你想要的未來**
  - 我們的責任是創造一個我們都想要的未來
  - 當我們做的事情違背了這個理念時, 要有勇氣說"不!"
- 提示 100. `這是您的人生, 請分享它, 慶祝它, 建造它, 並保持著愉快!`

---
