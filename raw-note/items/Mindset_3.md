## The Pragmatic Programmer

### The Pragmatic Programmer, 中文版, ComputerScience/Mindset

---

第一章 - 務實的哲學

第二章 - 務實的方法

第三章 - 基本工具

第四章 - 務實的偏執

第五章 - 彎曲或弄壞

第六章 - 並行

第七章 - 當您寫程式時

第八章 - 專案啟動前

第九章 - 務實的專案

第十章 - 後記

---

### 第一章 - 務實的哲學

- 提示 1. `重視您的手藝`
- 提示 2. `思考!您的工作` Think!
  - 思考取代直覺

這是您的人生

- 提示 3. `您擁有改變的能量`
  - 行動! 這個行業有各種不同的可能性

貓吃了我的原始碼

- 不害怕承認無知和錯誤，務實的面對問題的發生，並且我們會盡可能專業的處理他
- **團隊信任**，互相信任的團隊，團隊能信任你，你也能信任團隊
- **負責**，對自己的承諾負責。並且有權拒絕承諾風險過高和做不到的責任
- 提示 4. `請提供解決問題的選擇，停止製造爛藉口`
  - 當問題出現時，應該要做的是提供解決方案的選擇，而非藉口。
  - 藉口意味著不專業，像專業人士一樣承擔責任與提供解決方案

軟體亂度 entropy

- 提示 5. `不要讓破窗存在` **重要**
  - 良好的軟體是需要時常的維護
  - 取決於做專案時的文化與心理
  - 避免亂度在軟體中擴散
- **首先，不要傷害**
  - 不要因為出現危機就進行附帶傷害的解決方案，一個問題已經夠麻煩了。

石頭湯與煮青蛙

- 提示 6. `成為改變的催化劑`
  - 記得石頭湯士兵的故事
- 提示 7. `記得大方向`
  - 除了自己在做的事情之外，需要經常環顧周圍發生的事情，關注大局。
  - 避免成為溫水煮的青蛙
- **訓練**事態感知 situational awareness
  - 養成如同特種部隊一般，時時刻刻注意和仔細觀察周圍環境的習慣

夠好的軟體

- **承諾不可能實現的完成時間，和為了滿足最後期限而偷工減料，兩者不專業的程度是相同的。**
- **足夠好的軟體就是最好的軟體**
  - **讓使用者參與功能的取捨和品質的取捨**
  - 避免功能膨脹 feature bloat, **記得多數軟體被使用到的只有少數幾個核心的功能**, 更多的功能代表可能引進更多的 bug 或安全性問題
- 提示 8. `把品質看成一種需求`
  - 很多時候對於使用者來說，今天堪用的軟體勝過明天完美的軟體
- **知道何時停手**
  - 如同繪畫一般
  - 不要因為過分的修飾和精煉而破壞了完美的程式，去做下一件事
  - 程式碼可能並不完美，但是也不用擔心。也不可能是完美的

您的知識資產

- **對知識的投資永遠都得到最好的回報**
  - 知識與經驗是會過期的資產
  - **更重要的是學習新事物的能力是最重要的戰略資產**
- 投資知識資產，如同長期投資使用一樣的原則
  - **定期投資**
  - **多樣化**
  - **管理風險**
    - 平均投資在高風險與低風險上
  - **低買高賣**
    - 在某項技術變流行之前就學習他，衝浪!
  - **審查和調整**
    - 定時的審查和調整
- 提示 9. `請定期投資你的知識資產`
- 適當的目標
  - **每年至少學一門新語言**
  - **每個月閱讀一本技術書**, 想要深入理解, 仍然需要長篇的書籍
  - **也要閱讀非技術類書籍**, 軟體是被人所使用, 應該更瞭解整個社會和人
  - **上課**, 尋找有趣的課程
  - **參與本地使用者群組或會議**, 了解公司以外的人在做什麼，不要只去聽要積極的參與, 孤立對你的職業生涯可能是致命的
  - **體驗不同的環境**, 各種不同的開發環境, Windows, Linux, IDE, editor, ...
  - **了解目前發展**, 閱讀和當前專案不同的技術相關文章
- 學習的過程會擴張思維，思維的交叉交流很重要
- 把握學習的機會, **遇到問題, 疑問, 不知道的事情時, 不要讓事情就這麼過去**
- 提示 10. `批判式的分析你讀到或聽到的東西`
- **批判性思考**
  - 五個為什麼, 深入問題的, 一層一層的詢問為什麼
  - 這對誰有好處, follow the money
  - 時空背景是什麼? 對誰最好, 先決條件是什麼? 短期和長期的影響?
  - 何時何地可用? 什麼情況下, 什麼時候, 後果的後果是什麼?
  - 為什麼會有這個問題? 是否有某種模式讓問題發生? 底層是怎麼運作的?

溝通

- 提示 11. `將您的母語視為另外一種程式語言`
  - 溝通! **重要**
  - 了解你的聽眾, 溝通是建立在聽眾聽得懂的事情上, 成功的傳達
  - 知道你想說什麼, 優先思考和精煉大綱和要表達的東西, 之後才是寫作
  - 選擇適合的時間, 在對的時機討論對的事情
  - 選擇一個風格, 配合聽眾調整輸出的風格
  - 讓他看起來棒棒的, 文件的品質看起來好看也很重要
  - 當一個聆聽者
  - 回覆別人, 訊息, email, ...
- 提示 12. `您說了什麼話，與您如何說這些話一樣的重要`
- **溝通越有效, 影響力越大**
- 提示 13. `內建文件說明，不要硬綁上去`
  - 說明文件, 最好是依附著程式碼
  - 文件是軟體開發過程的一部分, 並且應該遵循軟體品質
  - **記得 DRY 原則, 不要讓程式碼與註解說一樣的事情**

---

### 第二章 - 務實的方法

- 目標是產出靈活且適應性強的軟體

優秀設計的精隨

- 提示 14. `一個好的設計比爛設計更容易改動`
  - ETC, Easier to Change, **重要**
  - 對於東西來說**使用者容易習慣使用**就是好設計
  - 對於程式來說開發者**容易改變**就是好的設計
- ETC 是一種價值觀, 一個 guide
  - **學習新想法時初期應該刻意的使用這些想法, 直到它變成環境觀察的一部分**
  - 跟隨 ETC 的想法做決策並且應該嘗試改變程式碼來確認, 持續做著這件事情系統會自然而然形成低耦合 loose-coupling 與內聚性 cohesion
- **嘗試紀錄決策, 形成決策日誌, 可以用來回顧與參考**

DRY - 重複的罪惡

- 維護並不是一個獨立的活動, 而是整個開發過程中的常態活動
- 在維護時我們必須**找到**並且**修改**
- 提示 15. `DRY 原則 - 不要重複`
  - 在一個系統中,每一條知識都必須有一個單一的, 明確的, 權威的表述
  - **重要** 最重要的工具之一
  - DRY 指的是**知識**與**意圖**, 而非單純的重複的程式碼或者表達型態
  - **環境觀察**: 在修改時是否需要在其他地方進行修改, 儘管表達方式可能不同
- 不是所有重複的程式碼都屬於知識複製
  - DRY 原則需要挑出來的是重複的知識, 而非重複的程式碼
  - 重複的程式碼但是乘載不同的知識, 那麼程式碼的相似只是巧合而已
- 文件的重複 (程式碼與註解之間的重複),
- 資料的重複 (可運算的資料變成變數需要額外的維護)
- 表示形式的重複, 內部 API 之間的重複與外部 API 之間的重複 (應該以集中存放與統一格式標準設計)
- 開發者的重複 (重點在於 knowledge sharing, 只有知識能被交流才有可能重用)
  - 實務上可以建立 daily scrum standup meeting,
  - 建立非同步的討論區 slick, wiki, 永久儲存且討論
  - 每個 codebase 存在一名專案圖書館員, 工作是促進知識的交流, 包含了促進 code review, 把共用函式放在相同的地方, ...
- 提示 16. `容易重複使用`
  - 建立一個容易找到且重用現有內容的環境,
  - 沒有這樣的環境, 人們就不會重用程式碼, 沒有重用就有重複知識的風險
- 封裝的模組與資料結構, 應該對外使用統一的標記法, 不應該洩漏內部是使用 cache 或計算

正交性 orthogonality

- 獨立 (independent), 去耦合 (decoupling), 線性獨立, 高內聚的 (cohesion)
- 提示 17. `消除不相關的東西對彼此造成的影響`
- 提高生產力
  - 修改被限制在特定的部分, 減少測試與開發的時間
  - 更容易重用
  - 正交的元件能形成的組合更多, 在組合後提供更多的功能
- 降低風險
  - 問題被隔離在特定的部分
  - 可以針對特定部分進行修改與修復
  - 更容易測試
  - 不予外部 (供應商, 產品, 平台, 第三方) 耦合, 以介面隔離於部分
- 個別的元件相依於抽象的介面, 而非實體
- **如果我大大改變某個特定功能背後的需求, 會有多少模組受到影響?**
  - 以這個問題詢問來測試正交性, 理想的情況下是 1
- 還要檢視系統對於真實世界的相依性
  - 避免相依於無法控制的東西
- **工具集與函式庫**
  - **明智的選擇引入的技術, 注意到系統的正交性**
  - 想想 Design Pattern
- 撰寫程式碼
  - 在撰寫程式時, 很容易就破壞正交性, 也許是重複的知識與功能
  - **讓你的程式保持著去耦合的狀態**
  - **避免全域變數** (儘管只是 read 在轉換成多執行緒時仍然會發生問題)
  - **避免相似的功能**
  - 養成不斷批評自己程式碼的習慣, 並且尋找任何機會重新組織他 (refactoring)
- 測試
  - 具正交性的系統更容易測試
  - **撰寫單元測試同時也是很好檢視正交性的方式**
  - 在進行 bug 修復時, 也是檢視系統正交性的好時機, **紀錄 bug 修復時所影響的模組或檔案數量**, 並且每個月追蹤檢視
- **總是保持正交性**
  - **盡可能地符合正交性與 DRY 原則**, 這樣的系統會更靈活, 容易理解, 容易除錯, 測試, 維護, 新增功能, ...

可逆性 reversibility

- 僵化來自於關鍵的決定不容易被逆轉
- 應該使用不同的方式**讓我們不必做關鍵且無法逆轉的決定**
  - 例如 DRY 原則, 去耦合, 外部設定
- 與資料庫系統的綁定, 應該建立在對資料庫概念的抽象化上
  - **系統應該相依在對於概念抽象化的介面上**, 而非任何的實體
- 提示 18. `根本沒有所謂的最終決定`
- 無法預測未來的變化與需求, 想想軟體架構的演進
  - 我們要做的是**讓改變變得容易**
- 提示 19. `不去管未來流行什麼`

曳光彈 tracer bullet

- Tracer bullet 在黑暗中提供即時且真實的回饋
- 提示 20. `利用曳光彈找到目標位置`
- Tracer bullet development
  - 概念等同於 Agile 開發, 擁抱改變小型迭代並且可運作的程式
  - 以小型路徑建立 end-to-end 的穿破所有層的架構
- 優點:
  - 使用者可以即早看到成果並且提供反饋
  - 開發人員建構了一個工作架構, 一個 end-to-end 都存在的架構
  - 有一個整合平台, 當架構存在後即存在一個可以時常執行 unit test, integration test 的平台
  - 有成果可示範, 永遠有一個可運行的成果, 可以展示 demo
  - 能感受到進步, 迭代的進步是可視的
- 曳光彈並不會總是擊中目標
  - **改變應該是容易且快速完成的**
- Prototyping 與 tracer bullet development 的差別
  - Prototyping 在建立原型後會丟棄所有的實作, 並且以學到的經驗重新撰寫程式
  - Prototyping 可以做為 tracer bullet development 的前導偵查
- Tracer bullet development 開發的程式碼就是最終系統中的一部分

原型和便利貼

- Prototyping 在早期以低成本建置, 目的在於分析, 揭露風險, 學習
  - 並不一定需要寫程式, 常常以白板, 便利貼, 即可建立提供思考
  - 細節不重要
  - 最終將會丟棄, 建立在此之上應該低成本的建立, 否則就是 tracer bullet development
  - **正確的使用 prototyping 帶來的是在開發早期識別且糾正潛在的問題點**, 以節省大量的金錢, 時間, 痛苦
- 如果處於**無法放棄細節**的環境, 應該改用 tracer bullet development 取代 prototyping
- 對於任何未知, 有疑慮的事物皆可進行 prototyping
- 提示 21. `原型的目的是學習`
- 建置原型時可以忽略 正確性, 完整性, 強健性, 風格
- 在 prototyping 時通常**希望回答特定領域的問題**, 例如
  - 主要領域的權責是否明確且適當?
  - 主要元件之間的協作是否定義良好?
  - 耦合是否已經最小化?
  - 能否找出潛在的重複部分?
  - 可否接受介面的定義與限制?
- 當環境且文化中, 使用 prototyping 會有誤解時, 應該改用 tracer bullet development

領域語言 domain languages

- 提示 22. `緊靠問題所在的領域`
- 使用問題領域的詞彙, 語法, 語意
- 內部的領域語言, 例如 RSpec, Phoenix, 固定於特定語言的語法上
- 外部的領域語言, 例如 Cucumber, Ansible, 以文件符合特定標準存在, 需要配合其他實作的解析器使用, 因此不會受限於單一語言上
- 建議: **花費的努力不要比省下的錢多**, 自行定義領域語言會增加成本, 並且需要確保節省下來的錢更多

評估 Estimating

- 預估是一個需要學習並且發展的技能
- 提示 23. `評估可以免除驚嚇`
- **回答的單位會影響精確度的預期** 重要
  - **慎選回答時的單位**
  - 範例: 回答 130 個工作天與 6 個月, 所預期的精確度範圍是不同的
- 預估最好的方式來自於**問已經做過的人**或有類似經驗的人, **成功借鑒他人經驗**
- 流程
  - 理解被問的問題, **重點在於範圍 (限制)**
  - 建立系統模型, 預測時的心理模型
  - 將模型分解為元件, 思考每個元件之間的**互動**與**參數**
  - 將每個參數都給一個預估值, **重點在找出哪些參數影響結果最大, 並且盡可能地讓這項參數預測值更正確**
  - 計算答案
- **紀錄每次的評估**
  - **在預估錯誤時, 找出問題點, 提升預估能力**
- Program Evaluation Review Technique, PERT
  - 預估時不是回答單一結果, 而是一個區間
  - 最樂觀的預估值, 最有可能發生的預估值, 悲觀的預估值
- 對於專案預估最準確的方式是**建立在同一專案多次迭代的經驗**
  - 以 incremental development 進行
  - Agile 在多次迭代後, 能提供更準確的預測
- 提示 24. `使用程式碼迭代時程`

---

### 第三章 - 基本工具

- 工具會放大才能, 工具越好越熟練使用, 效率就越好
- 打磨且充實自已的工具庫, 並且在不夠用時, 向外探索尋求適合的工具

純文字的威力

- 程式設計師的**基礎原料是知識**
- 提示 25. `在純文字中保存知識`
- 有結構的純文字, 例如 HTML, JSON, YAML
- 純文字的優點
  - 不會過時, 確保純文字的 human understandable
  - 利用現有工具, 純文字檔案可以很好的被 _version control_, _diff_, _checksum_
  - 更容易測試,
  - 更好搜尋
- 最小共用分母, 無論科技如何發展, 純文字始終是共用的標準

Shell

- shell 等同於木工的工作檯
- 提示 26. `善用命令 Shell 的力量`
- shell 能更好的自動化, 並且提供完整的功能, 與客製化的能力
- 有時候我們會客製化 shell 的 color theme, prompt, alias, autocomplete 等等

Editor

- 提示 27. `熟練編輯器`
- 練習無滑鼠操控編輯器
- 流暢使用編輯器
  - 以字元, 單字, 行, 段落, 移動且選擇
  - 可以依據不同的語法單元移動, 例如分隔號, 函式區塊, 模組
  - 修改後縮排程式碼
  - 快速註解與取消註解
  - 還原與重做
  - 視窗分割與切換
  - 移動到行號
  - 依據字串, regular expression 搜尋並且允許同時修改所有的搜尋點
  - 顯示編譯錯誤
  - 執行專案測試
- 學習編輯器的 extension 與撰寫, 在需要時有能力客製化

Version Control

- 提示 28. `一定要使用版本控制`
  - 所有的東西都在版本控制之下
- **刻意練習**在舊電腦壞掉時, 能多快速的在新電腦上還原一切
  - 所有的設定, SSH key, 安裝的應用程式, ...
- 版本控制當作專案中心
  - 選擇一個中央儲存庫的系統並且良好的支援
  - 存取控制, 安全性
  - 好用的 UI
  - 命令列執行所有的操作, 可以自動化
  - 自動化建構與測試, CI 環境
  - Brach merge (pull request) 支援
  - 問題管理, issue tracking, 最好能整合 PR 或 Commit
  - 良好的報告, 提供類似 Kanban 的專案管理
  - 良好的團隊溝通, 一些 hook 支援各種類型的通知

Debug

- 提示 29. `解決問題, 而不是責備某人`
  - debug 只是在解決問題
- 提示 30. `不要慌`
  - 關閉自我防備的心理
- **總是試圖發現問題的根本原因, 而不僅僅是問題的表面現象**
- 從哪裡開始
  1. 確認能編譯的過並且沒有任何的錯誤訊息 (讓自動化工具先除錯)
  2. 可能需要與 bug 回報的使用者會面來蒐集更多資訊
  3. 嚴格的邊界測試與實際使用者模式測試
- 提示 31. `在修復程式之前先進行錯誤測試`
- 除錯策略
- **先撰寫能重現錯誤的測試**
- 提示 32. `請一定要讀那該死的錯誤訊息`
  - **閱讀錯誤訊息**
- 錯誤結果的 bug, 使用 **debugger** 來追蹤不正確的值的來源
- **使用 binary chop 來加速尋找崩潰的位置, 有問題的值集合, 有問題的版本**
- 以 **log** 或 **trace** 尋找與時間相關的 bug
  - 範例: 追蹤 resource leak 時, 在每次 open 與 close 地方加上 log
- 塑膠黃色小鴨
  - 試著解說程式碼給其他人聽, 透過解說必須以不同面向或更深入的思考程式碼
- 提示 33. `'select' 沒有壞掉`
  - 應該優先尋找可控範圍內的錯誤, 而非把錯誤歸咎於其他服務 (OS, library, framework, ...)
- 提示 34. `不要假設, 請去證明`
  - 不要假設某些程式是正確的, 而是要證明他是正確的才可信
- 對於驚嚇的 bug 要去進行優化
  - 下次如何更快速的找到 bug
  - 是否需要其他方法讓錯誤更早顯現, 例如各種 testing, function attributes check

操作文字

- 提示 35. `請學習一門文字操縱語言`
  - 例如 Python, Ruby, ...
- 可以輕易的處理文字相關的事情
- 例如格式之間的轉換, 搜尋, 修改, 測試

工程日誌

- 使用手寫的日誌
- 紀錄當下任何的事情
- 當寫滿後寫下日期範圍

---

### 第四章 - 務實的偏執

- 提示 36. `你無法寫出完美的軟體`

合約式設計

- Design by Contract (DBC), 由 **Eiffel** 此物件導向語言所發明
- 重點在於**紀錄合約**與**驗證合約**
- 針對方法或函式在**實作之前**先思考與定義合約
  - 合約定義所有成功與失敗的情況與處理
  - 簡單列舉輸入範圍, 邊界條件, 函式承諾的交付, 函式不承諾的交付
  - 除了程式語言直接的支援之外, 也可以將合約以**註解**或者**單元測試**的方式加入
- 前置條件 Precondition
  - 在呼叫時什麼東西必須是正確的, 違反時函式應該不被執行
  - **傳遞正確的資料是呼叫者的責任**
- 後置條件 Postcondition
  - 完成時的狀態
  - 函式的執行承諾
- 類別**不變量** Class invariant
  - 在類別中永遠必須符合的條件
- 函式與呼叫者之間的合約可以被解讀為
  - 呼叫者滿足所有前置條件, 函式在完成時保證所有後置條件與不變量成立
- **無論呼叫者或函式不能滿足合約時**
  - 應該會呼叫事先約定好的補救措施
  - **任何一方不能履行合約都是個錯誤**
- 提示 37. `用合約進行設計`
  - 重點在於**懶惰的**合約
  - 嚴格要求能接受的東西, 並且盡可能少的執行承諾 (單一責任原則)
- 與防禦性程式設計的差別
  - 防禦性程式設計, **每個人**都進行資料驗證與檢查
  - 合約式設計, **由呼叫方保證輸入值的正確性** (更 DRY 的作法)
- **早期崩潰**
  - **盡早使程式崩潰並且回報更準確的問題資訊** 重要
  - 越早發現問題越容易除錯
- 語意**不變量** semantic invariant
  - 一種哲學合約 philosophical contract
  - **如果發現或找出固定的, 且永遠不可違反的需求, 應該把他清楚地列出來讓所有人知道**
  - 例如: 交易程式永遠不應該重複扣款
  - 清晰, 簡約, 明確的描述並且每個人都應該看得到且遵守

死程式不說謊

- 提示 38. `早期崩潰` 重要!
  - 當錯誤發生時, 直接讓他崩潰造成更小的損害
  - 延遲錯誤只會讓錯誤被傳遞, 擴大損害範圍與增加除錯的難度
- 盡可能地讓程式早點崩潰, 與其浪費時間進行防禦性程式設計, 直接讓他崩潰
- 崩潰的程式會由管理器 (supervisor) 管理, 階層的管理器會知道如何處理錯誤, 例如自動重開機, 自動重新啟動, ...

assertion 式程式設計

- 提示 39. `請使用 assertion 避免不可能發生的事`
- 以 assert 形式, 來**讓不可能發生的事情**現形
  - 必須與正常的錯誤處理區隔
- assert 的執行必須是**沒有副作用的**
  - 如果發生例外記得正確的處理
- 在 production 環境仍然要開著 assertion 的功能, 來捕捉實際可能遇到的錯誤
  - 如果遇到效能問題, 也只能關閉真的影響效能的 assert, 而非完全關閉
- **精心設計的 assertion 保護 production 環境能捕捉所有的失敗與相關訊息**
  - 讓 bug 發生時在第一時間最真實的被捕捉並且帶有相關資訊
  - 免除開發者要去重現模糊且難以複製的 bug

如何平衡資源

- 提示 40. `由取得資源的人負責釋放資源`
  - 去除資源管理造成的耦合
- 提示 41. `在小區域進行動作`
- 巢狀取得資源
  - 注意取得資源與釋放資源的順序要相反, 避免產生 leak
  - 當有多個位置取得同一資源時, 要注意 deadlock 的可能性
- 物件與例外處理
  - 把資源封裝在物件內部, 並且會在解構時釋放資源
  - 在遇到例外處理可能干擾資源釋放時特別好用 (如果物件超過 scope 時會自動被釋放)
- 如果使用 \*_try...catch...finally_ 模式處理時
  - **記得取得資源的語法應該放在 try 之外**, 避免在 finally 階段可能去釋放根本沒取得的資源
- **檢查平衡** 重要!
  - 務實的程式設計師不相信任何人包含自己
  - **對資源管理進行檢查**, 不管是高階或者低階的
  - 確保沒有 memory leak
- _補_, 理解所使用的程式語言的垃圾回收機制

不要跑得比您的車頭燈還快

- 提示 42. `每次總是只走一小步`
  - 小步小步走, 並且在走下一步之前檢查回饋和調整
  - 不僅僅限於程式設計
- 車頭燈的範圍代表**可控制的範圍**
  - 任何需要進行算命的範圍都是超過範圍的 (**需要猜測就代表超過範圍**)
  - 只為能看到的範圍負責
- 與其浪費精力在為不確定的未來設計, **還不如把程式設計的更容易替換**
  - 意味著高內聚, 低耦合, DRY, 更好的架構設計

---

### 第五章 - 彎曲或弄壞

---

### 第六章 - 並行

---

### 第七章 - 當您寫程式時

---

### 第八章 - 專案啟動前

---

### 第九章 - 務實的專案

---

### 第十章 - 後記

---
