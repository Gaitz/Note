## GeeksForGeeks C++ tutorial

### [Website resource](https://www.geeksforgeeks.org/c-plus-plus/), Backend/C++

---

第一章 - C++ Overview

第二章 - C++ Basics

第三章 - C++ Variables and Constants

第四章 - C++ Data Types and Literals

第五章 - C++ Operators

第六章 - C++ Input/Output

第七章 - C++ Control Statements

第八章 - C++ Functions

第九章 - C++ Pointers and References

第十章 - C++ Arrays

第十一章 - C++ Strings

第十二章 - C++ Structures and Unions

第十三章 - C++ Dynamic Memory Management

第十四章 - C++ Object-Oriented Programming

第十五章 - C++ Encapsulation and Abstraction

第十六章 - C++ Polymorphism

第十七章 - C++ Function Overloading

第十八章 - C++ Operator Overloading

第十九章 - C++ Inheritance

第二十章 - C++ Virtual Functions

第二一章 - C++ Exception Handling

第二二章 - C++ Files and Streams

第二三章 - C++ Templates

第二四章 - C++ Standard Template Library (STL)

第二五章 - C++ Iterators

第二六章 - C++ Preprocessors

第二七章 - C++ Namespace

第二八章 - Advanced C++

第二九章 - C vs C++

第三十章 - C++ vs Java

第三一章 - Competitive Programming in C++

---

### 第一章 - C++ Overview

Introduction to C++

Features of C++

History of C++

Interesting Facts about C++

Setting up C++ Development Environment

Similarities and Differences between C++ and C

---

### 第二章 - C++ Basics

First C++ Program

- Hello World Program

  ```C++
  #include <iostream>
  using namespace std;
  int main()
  {
    cout << "Hello World";
    return 0;
  }
  ```

C++ Basic Syntax

- Header File
  - 包含函式的定義 (function) 和 marcos
- Namespace
  - 用來避免 name conflicts
- Main Function
  - Function 是 C++ 最基礎的單元
  - `main` function 是最重要的起點
- Blocks
  - 由 `{}` 包裹, 用來定義 scope
- Semicolons
  - `;`, 必要的, 代表一段語法的結束
- Identifiers
  - 命名
  - 變數, 函式, 自定義資料型態
- Keywords
  - 保留字
  - 不可以做為 identifiers 使用
- Basic Output `cout`
  - `cout << variable_name;`
- Object-Oriented Programming in C++
  - C++ 支援 procedural-oriented 與 object-oriented programming 兩種範型
  - `class`
  - Data Members
  - Member Functions

C++ Comments

- 註解
- 單行註解, `//`
- 多行註解, `/* */`
- 對於 compiler
  - 註解會被 Lexical Analyzer 過濾掉

C++ Tokens

- 每個在 source code 中的 word 都是 token
- 分類
  - Identifiers
  - Keywords
  - Constants
  - Strings
  - Special Symbols
    - `;`, `[]`, `{}`, `::`, `.`, `=`, `"`, `'`
  - Operators
    - Unary Operators, `++`, `--`
    - Binary Operators
      - Arithmetic Operators, `+`, `-`, `*`, `/`, `%`
      - Comparison Operators, `==`, `!=`, `<`, `>`, `<=`, `>=`
      - Logical Operators, `&&`, `||`, `!`
      - Assignment Operators, `+=`, `-=`, `*=`, `/=`, `%=`
      - Bitwise Operators, `&`, `|`, `^`, `~`, `<<`, `>>`
    - Ternary Operators, `? : ;`

C++ Identifiers

- 獨特的命名, unique name, 來定義 variables, functions, classes, structs, ...
- 命名規則
  - 使用 `A-Z` or `a-z`, `0-9`, `_`
  - 只允許字母或底下作為開頭
  - 不允許使用保留字 (keywords)
  - 在同一個 namespace 下必須是唯一的
  - C++ 是 case sensitive, 大小寫有別

C++ Keywords

- `asm`
- `auto`
- `break`
- `case`
- `catch`
- `char`
- `class`
- `const`
- `continue`
- `default`
- `delete`
- `do`
- `double`
- `else`
- `enum`
- `extern`
- `float`
- `for`
- `friend`
- `goto`
- `if`
- `inline`
- `int`
- `long`
- `new`
- `operator`
- `private`
- `protected`
- `public`
- `register`
- `return`
- `short`
- `signed`
- `sizeof`
- `static`
- `struct`
- `switch`
- `template`
- `this`
- `throw`
- `try`
- `typedef`
- `union`
- `unsigned`
- `virtual`
- `void`
- `volatile`
- `while`

Difference between Keyword and Identifier

---

### 第三章 - C++ Variables and Constants

C++ Variables

- 變數是為一個記憶體空間的命名
- C++ 中變數必須先宣告 (declared) 才能使用
- `type variable_name;`
- 關於 Variable Scopes, 變數可被分成
  - Local Variables, 關於任何 block
  - Instance Variables, 關乎 class
  - Static Variables, 關乎 class, 使用 `static` 進行宣告

C++ Constants

- Constants, 在整個執行期都是固定的值
- Constants 在 C++ 中代表一個變數的值, 在執行期永遠不會改變
- 定義方式有以下三種
- `const`, 來自 C 語法, 在宣告變數時加上前綴 `const` 並且宣告時必須初始化
  - 初始化可以來自於 runtime 或 compile time
- `constexpr` 與 `const` 類似但是, 初始化必須在 compile time 時就知道值
- `#define` 使用 preprocessor 定義常數 (macro constants)
  - preprocessor 進行的事情只是單純的文字替換

Scope of C++ Variables

- Local Variables, 區域變數
- Global Variables, 全域變數
- 當區域變數與全域變數同名時
  - 區域變數優先於全域變數
  - 如果使用 `::` scope resolution operator 作為前綴的話, 可以取得全域變數

C++ Storage Classes

- C++ 儲存類別
- 可以指定變數的儲存類型, 會影響變數 lifetime, scope, initial value 和儲存位置
- 分成六種並且有對應的 keywords
  - auto, 預設模式
  - `register`, C++11 後 deprecated, 暗示 compiler 希望使用 CPU register 儲存
  - `extern`, 預設值為 0, 在任意地方主動定義的 global variable
  - `static`, 預設值為 0, 不會消失, 會一直存活在呼叫處, (例如, 永遠存活在該函式 body 內)
  - `mutable`, class based
  - `thread_local`, thread based, C++11 以後支援

C++ Static Variables

- `static` keyword 使用上可以分成兩種類型
  - Static Variables,
    - 像是在 function body 宣告的 static variable
  - Static Members of Class,
    - 存在 class 內, 由 objects 共享

---

### 第四章 - C++ Data Types and Literals

C++ Data Types

- 所有的變數都需要事先宣告其資料型別, 資料型別讓 compiler 決定要給予該變數多少的記憶體空間
- Data types 的類型可以分為
- Primary, Built-in, Fundamental data type
  - Integer, `int`, `short`, `long`
  - Character, `char`
  - Boolean, `bool`
  - Floating Point, `float`
  - Double Floating Point, `double`
  - Void, `void`
  - Wide Character, `wchar_t`
- Derived data types
  - Function
  - Array
  - Pointer
  - Reference
- User-defined data types
  - Class
  - Structure
  - Union
  - Enum
  - Typedef
- `sizeof()` operator, 取得變數或資料型態的記憶體大小
- Datatype Modifiers
  - Signed, `signed`
  - Unsigned, `unsigned`
  - Short, `short`
  - Long, `long`
- Macro Constants
  - `CHAR_MIN`, `CHAR_MAX`
  - `SCHAR_MIN`, `SCHAR_MAX`, `CHAR_BIT`
  - `MB_LEN_MAX`
  - `SHRT_MIN`, `SHRT_MAX`, `USHRT_MAX`, `INT_MIN`, `INT_MAX`, `UINT_MAX`, `LONG_MIN`, `LONG_MAX`, `ULONG_MAX`, `LLONG_MIN`, `LLONG_MAX`, `ULLONG_MAX`

C++ Literals

- 數值的表示, 分成
- Integer Literals, 整數
  - 沒有小數部分單純的整數, 直接以數字表達
  - 8 進位, 前綴為 `0`, 16 進位, 前綴為 `0x`, 2 進位, 前綴為 `0b`
  - 長整數 (`long int`), 後綴為 `L`, `l`
  - 無號整數 (`unsigned int`), 後綴為 `u`, `U`
  - 長整數 (`long long int`), 後綴為 `ll`, `LL`
- Floating Point Literals, 浮點數
  - `double`, 預設值, 不需要前綴或後綴
  - `float`, 後綴為 `f`
- Character Literals, 字元
  - 包裹在 `' '` 中
- String Literals, 字串
  - 包裹在 `" "` 中
- Boolean Literals, 布林值
  - `true`, `false`

C++ Derived Data Types

- Function, 函式宣告
  - `FunctionReturnType FunctionName(Parameters)`
- Array, 陣列
  - `DataType ArrayName[SizeOfArray]`
  - C++ 陣列宣告時需要提供陣列數量 (固定長度, 記憶體空間)
- Pointers, 指標
  - `DataType* VariableName`
  - 儲存指向指定資料型態的記憶體空間位置
- References, 參考
  - `DataType& ReferenceName = VariableName`
  - 其他變數的別名, (分享相同的記憶體位置)

C++ User-Defined Data Types

- 使用者定義的資料型別
- Class
  - `class ClassName {};`
  - 包含 data members 與 member functions
- Structure
  - `struct StructName {};`
  - 資料型別的聚集
- Union
  - `union UnionName {};`
  - 類似 Structure 但是內部所有的型別分享同一個記憶體空間
- Enumeration
  - `enum EnumName {};`
  - 數字 Enum
- Typedef
  - `typedef TypeName;`
  - 自行定義型別, 建立現有資料型別的別名
  - 用來提供更好的可閱讀性和移植性 (與實際資料結構有介面隔離)

C++ Data Type Ranges and Their Macros

- 使用 C++ macro constants 來取得資料型別的最大與最小值

C++ Type Modifiers

- 修改 primitive data type 的細節
- `signed`, 有號的, 代表能儲存 positive, negative, zero, 多數時候是預設值
  - 適用於 `int`, `char`
- `unsigned`, 無號的, 僅能儲存 non-negative values,
  - 適用於 `int`, `char`
- `short`, 縮小使用的記憶體空間, 也代表縮小能儲存值的範圍,
  - `short int` 等同於 `short`
- `long`, 增加使用的記憶體空間, 也代表增加能儲存值的範圍
  - `long int` 等同於 `long`
- Type Qualifiers, 控制變數值的操作行為
  - `const`, 無法被再次修改的
  - `volatile`, 向 compiler 表達, 該變數可能會被程式本體以外的因素修改, 例如 OS, hardware, ...
    - 調整 compiler 對該變數的優化選項
  - `restrict`, 針對 pointer 變數專用的 modifier,
    - 由工程師保證該 pointer 所指向的對象, 不會被其他 pointer 指向 (保證是唯一 pointer)
    - 避免某些複數個 pointer 指向相同位址的情境, 提升 compiler 優化的選項

C++ Data Type Conversion

- 資料型別轉換, 分成
- Implicit Type Conversion 隱性轉換
  - Compiler 已知的安全轉換 (不會丟失資料)
  - 所有相同的資料類別由小轉大
    - `bool` -> `char` -> `short int` -> `int` -> `unsigned int` -> `long` -> `unsigned` -> `long long` -> `float` -> `double` -> `long double`
- Explicit Type Conversion 顯性轉換
  - 使用者明確表明的型別轉換, 強制轉換, 可能會丟失資料
  - 語法 1. `(type) expression`
  - 語法 2. Cast operator `<type>`, 分成四種類型
    - Static Cast
    - Dynamic Cast
    - Const Cast
    - Reinterpret Cast

C++ Typecasting Operators

- Casting operators 四種類型
- `static_cast <NewType>`
  - Compiler time 的轉換
  - library `typeinfo` 存有函式 `typeid()` 可以協助我們確認型別資訊
- `dynamic_cast <NewType>`
  - 通常用於 Class pointer/reference 進行類別降轉, 會在 runtime 進行確認是否能安全轉換, 無法安全轉換會取得 `null` pointer 或丟出 `bad_cast_exception`
- `const_cast <NewType>`
  - 用於指向 `const` variable 的 pointer
  - 可以通過明確表明 `const_cast` 把 `const` variable pointer 轉換成可以修改值的 non-const variable pointer
  - 小心不可預期的錯誤, **不被推薦使用**
- `reinterpret_cast <NewType>`
  - 不進行任何安全確認的強制轉換
  - 小心不可預期的錯誤, **不被推薦使用**

---

### 第五章 - C++ Operators

C++ Operators

- 運算子, 分成六種
- Arithmetic Operators, 數值算子
  - 單元的, `++`, `--`
  - 雙元的, `+`, `-`, `*`, `/`, `%`
- Relational Operators, 比較算子
  - `==`, `>`, `>=`, `<`, `<=`, `!=`
- Logical Operators, 邏輯算子
  - `&&`, `||`, `!`
- Bitwise Operators, 位元算子
  - `&`, `|`, `^`, `<<`, `>>`, `~`
- Assignment Operators, 賦值算子
  - `=`,
  - `+=`, `-=`, `*=`, `/=`, `%=`,
  - `&=`, `|=`, `^=`, `<<=`, `>>=`,
- Ternary or Conditional Operators, 三元運算子, 條件算子
  - `Expression1 ? Expression2 : Expression3`

C++ Unary Operators

- 單元算子
- `++`, `--`
- `+`, `-`, 正負號
- `!`, 邏輯否定
- `~`, 位元 NOT
- `&`, 記憶體位置算子 (Address Operator)
- `*`, 取值算子 (Dereference Operator)
- `sizeof()`

C++ Sizeof Operator

- 取得記憶體大小
- `sizeof(DataType)`
- `sizeof(Expression)`

C++ Scope Resolution Operator

- `::` 範疇算子
- 可以用來在 local 取得同名的 global 變數
- 可以在 Class 外部定義, 新成員
- 取得 Class 的靜態成員 (`static`)
- 區分多重繼承 (multiple inheritance) 同名的成員
- 去調用巢狀定義 Class 的成員, (nested class)

---

### 第六章 - C++ Input/Output

C++ Basic Input/Output

- stream, 一個 bytes 的序列
- Input stream, 讀取進主記憶體 (main memory)
- Output stream, 從主記憶體輸出 (main memory) 到外部裝置
- IO 相關的 header files
  - `iostream`, 標準 IO, (`cin`, `cout`, `cerr`)
  - `iomanip`, manipulating IO, 調整 IO stream 相關的工具
  - `fstream`, 以檔案為目標的 IO
  - `bits/stdc++`, 一次讀入所有的標準函式庫, 在 CP 有時間競爭時, 可以取代一個一個輸入 header files
- C++ 中標準函式庫的 namespace 為 `std`
  - 因此會在所有的檔案中使用 `using namespace std;` 來一次性的加上前綴 `std::`
- `cout`, Standard output stream, 配合 `<<`
- `cin`, Standard input stream, 配合 `>>`
- `cerr`, Un-buffered standard error stream, 配合 `<<`
  - Un-buffered 代表會立刻發出
- `clog`, Buffered standard error stream, 配合 `<<`
  - Buffered 會先存在 buffer 中

C++ Standard Input Stream (`cin`)

- `cin` object 屬於 istream
- 單個 Input, `cin >>`
  - 多個 Input 以 `>>` 串連
- `cin.getline(char* buffer, int N)`
  - 一次讀取 `N - 1` 個字元, 或者遇到 end of file 或 newline `\n` 才停止
- `cin.get(char& var)`
- `cin.read(char* buffer, int N)`
- `cin.ignore()`

C++ Standard Output Stream (`cout`)

- `cout` object 屬於 ostream
- 單個 Output, `cout <<`
  - 多個 Output 以 `<<` 串連
- `cout.write(char* str, int n)`
- `cout.put(char& ch)`
- `cout.precision(int n)`, 控制輸出的浮點數精度

C++ Standard Error Stream (`cerr`)

- `cerr` object 屬於 ostream
- un-buffered 進行 error 輸出

C++ Input/Output Manipulator

- 對 iostream 進行控制
- Manipulators without arguments
  - `endl`, 定義在 ostream 中, 進行 new line 並且 flushes buffer
  - `ws`, 定義在 istream 中, 用來忽略 whitespaces
  - `ends`, 定義在 ostream 中, 插入 null 進入 output stream,
  - `flush`, 定義在 ostream 中, 立即清除 output stream buffer
- Manipulators with Arguments
- `iomanip` header 中的
  - `setw(val)`, width
  - `setfill(char)`, 塞入 char
  - `setprecision(val)`, 控制浮點數精度
  - `setbase(val)`, 設定數值的 base
  - `setiosflags(flag)`, 設定 format flags
  - `resetioflags(m)`, 重置 format flags
- `ios` header 中的
  - `showpos`, 強制顯示正數的 positive sign
  - `noshowpos`, 強制不顯示正數的 positive sign
  - `showbase`, 強制顯示數值的 base
  - `uppercase`, 轉換成 upper case
  - `nouppercase`, 轉換成 lower case
  - `fixed`, 使用 decimal notation 顯示浮點數
  - `scientific`, 使用科學記號的方式顯示浮點數
  - `hex`, 讀取或輸入使用 16 進位, 等同於 `setbase(16)`
  - `dec`, 讀取或輸入使用 10 進位, 等同於 `setbase(10)`
  - `oct`, 讀取或輸入使用 8 進位, 等同於 `setbase(8)`
  - `left`,
  - `right`,

---

### 第七章 - C++ Control Statements

C++ Decision Making

- conditional statements
- If Statement
  - `if (condition) {}`
  - `if (condition) {} else {}`
  - `if (condition) {} else if (condition) {} else {}`
- Switch Statement
  - `switch (expression) { case value1: break; case value2: break; default: }`
- Ternary Operator
  - `condition ? expression1 : expression2;`
- Jump Statements
  - `break`,
  - `continue`,
  - `goto`, 配合 label 進行跳躍
  - `return`,

C++ Loops

- 重複進行數次
- `for` loop,
  - `for (initialization_expression; condition; iteration_execution) {}`
  - `for (auto element:array)`, Range-Based for Loop
    - `for (auto& [key, value]: map_name) {}`
  - 使用 iterator pattern 的 for loop
    - `for_each(start_iter, last_iter, fnc)`
- `while` loop,
  - `while (condition) {}`
  - `do {} while (condition);`
- Infinite Loop
  - 沒有終止條件的 loop
  - 例如 `for(;;) {}`, `while(1) {}`

---

### 第八章 - C++ Functions

C++ Functions

- 重複的邏輯封裝成函式
- 函式宣告 `ReturnType function_name (Parameters) { function_body }`
- C++ 可以分離函式宣告 (Header) 與實作內容 (Function Body)
  - 呼叫任何函式前, 必須先有 header 被宣告或者 include
- 所有的函式都必須有 return type
- 如果沒有顯性的 `return`, function 會自動 return `void`, 等同於 `return;`
  - 因此如果沒有 return 的 function 需要使用 `void` 作為 Return Type 宣告
- Main Function
  - 程式的進入點
  - `int main() { return 0; }`, without parameters
  - `int main(int argc, char* const argv[]) { return 0; }`, with parameters
  - 回傳值 `0` 代表執行沒有問題
- Recursion
  - 函式裡面呼叫自身函式, 被稱為遞迴程式
  - 尾端遞迴 tail recursion
- Function Overloading
  - 同名異式
  - 同名函式, 但是簽名細節不同 (different parameters)

C++ Parameter Passing Techniques

- Pass by Value
  - 傳遞被複製的值作為參數
- Pass by Reference
  - 傳遞變數的地址作為參數, 函式宣告時, 使用 `&` 指定參數型別為 Reference
- Pass by Pointer
  - 傳遞 pointer 參數, 達成類似傳遞 reference 的方式進行

Difference between Call by Value and Call by Reference

- Call By Value in C
  - 是複製的值, 存放在不同的 address
- Call By Reference in C
  - 使用同一個 address

C++ Default Arguments

- 宣告時使用 `=` 在呼叫時沒有指定時提供預設值

C++ Recursion

- C++ 有 tail recursion 最佳化 (尾端遞迴最佳化)
  - 自動改寫成 loop 版本, 最佳化 memory 使用避免 stack overflow
- 遞迴的缺點
  - 效能較差 (需要 function call 造成的 overhead)
  - 空間使用效率較差 (需要 function call 造成的 overhead)
  - 不易 debug
  - 可能造成 stack overflow 導致程式崩潰

C++ Inline Functions

- 宣告函式時使用 `inline` 作為前綴 keyword 代表 inline function
- 讓 compiler 進行最佳化, 不實際實現 function 而是使用程式碼 copy 取代 function overhead
  - 使用額外的 register 去進行效能最佳化
- 使用時機只有在針對效能有極端要求, 並且 **function body 較小的時候才有優勢**
- 過多的 Inline function 會導致
  - binary code 過大, 因為有大量重複的程式碼
  - 降低 cache hit rate
  - 對於 embedded system 可能不適用, 因為 space 比 speed 更珍貴
  - 過大的 binary code 對於執行時的 main memory 是個考驗
- 在 C 中僅能使用 macro 達成類似的行為
  - 但是對於 C++ 相同情境應該優先使用 inline function 取代 macro
  - C++ 可以提供更多的 compiler time 驗證, 保證正確性

C++ Lambda Expression

- C++ 11 後提供 Lambda Expression 提供定義不需要被重用, 也沒有名稱的, 匿名 inline function
- `[ capture_clause ] (parameters) -> return_type { }`
  - return_type 不是必須的, 如果 compiler 可以推論時
- capture clause 代表呼叫外部變數時, 使用的模式,
  - 分成 `&`, 使用 reference; `=`, 使用 value

---

### 第九章 - C++ Pointers and References

C++ Pointers and References

C++ Pointers

- Pointers, 儲存記憶體位置的變數
  - `DataType* VariableName;`
  - 對變數使用 `&` 取得變數的記憶體位置
  - 使用 `*` 從記憶體位置取值
- C++ 函式參數
  - Call-By-Value
  - Call-By-Reference with a Pointer Argument
  - Call-By-Reference with a Reference Argument
- Array Name as Pointers
  - C++ 中 Array 是以 pointer 的方式實現的
  - 可以利用 Array 變數名稱取得陣列的開始位置 (即第一個元素的記憶體位置)

C++ Pointer Arithmetic

- 操作 pointer (arithmetic operations), 向前移動或向後移動記憶體位置
- `++`, `--`, `+`, `+=`, `-`, `-=`
- Difference between two pointers
- Incrementing and Decrementing Pointer in C++
  - `++`
  - `--`
  - 依據 32-bit 或 64-bit, 儲存的資料型別, 決定前後移動的距離
- Addition of Constant to Pointers, Subtraction of Constant from Pointers
  - 加 constant 代表向前幾個位置 (以資料型別 size 為單位)
  - 減 constant 代表向後幾個位置 (以資料型別 size 為單位)
- Subtraction of Two Pointers of the Same Datatype
  - 視為距離
- Comparison of Pointers
  - `==` 是否指向相同的位置
  - Comparison to NULL (`== NULL`), 得知 pointer 是否有儲存任何記憶體位置

Dangling, Void, Null, and Wild Pointers

- Dangling pointer, 指向已經清除的記憶體位置
  - De-allocation of Memory, 指向已經的記憶體位置被 `free` or `delete`
  - Function Call, 函式回傳區域變數的 pointer, 在外部時, 當函式已經執行完畢, 指向區域變數的 pointer 就成了 dangling pointer, 除非區域變數是 `static` 的
  - Variable Goes Out of Scope, 在外部調用不存在外部的變數 pointer
- Void pointer, `void*`, 一種 Pointer 的型別, 代表指向記憶體位置, 但是不知道資料型別
  - 可以指向任何記憶體位置, 但是 Void pointer 無法被 dereferenced, 除非先經過 type casting
- Null pointer, 有效但是空的位置 (nothing), `NULL` 代表 pointer 的值
- Wild pointer, 沒有初始化的 pointer, Pointer 的值可能是任何東西 (garbage value)

Applications of Pointers

- 主要用途
- Passing Arguments by Reference
  - 為了可以在函式內直接修改變數值
  - 提升效能 (空間或者時間的, 減少複製)
- For Accessing Array Elements
  - 使用 Pointer 去讀取陣列資料
- To Return Multiple Values
  - 函式回傳多個數值, 函式只能回傳單值, 因此通過回傳 Pointer 打包多個數值
- For Dynamic Memory Allocation
  - 手動的記憶體動態配置
- 實現複雜的資料結構
  - 像是 trees, graph, linked list

C++ nullptr

- 由於 `NULL` 通常是由 `void* 0` 所實現
  - 因此在型別上沒辦法正確區分 `int` 或者是 pointer
- 通過特別的 keyword, `nullptr` 與 `nullptr_t`
  - 明確指明為 Null Pointer

C++ References

- 定義型別為 Reference 代表該變數是其他變數的別名 (alias)
  - 宣告方式是 `TypeName&`
- 可能的使用時機
- Modify the passed parameters in a function
  - Call by reference
- Avoiding a copy of large structures
  - 類似使用 pointer, 提升效能
- In For Each Loop to modify all objects
  - 在 For loop 中直接修改變數值 (通過 Reference)
- For Each Loop to avoid the copy of objects
  - 在 For loop 物件結構時, 避免複製, 使用 Reference 取代值的複製
- Reference 與 Pointer 的比較
  - Pointer 可以是 Void, 但是 Reference 不行
  - Pointer 可以是多層的 (像是 pointer of pointer), Reference 永遠只有一層 (必須指向一個值, 不能是記憶體位置)
  - Reference variable 無法被重複賦值, 必須被初始化的
  - Reference variable 不能是 NULL
  - Reference variable 是 internal pointer 實現的, (可以視為 pointer 的語法糖)
- 使用 Reference 的優點是
  - 比起 Pointer 有更多限制, 因此更安全
  - 比起 Pointer 需要進行 dereference, Reference variable 使用起來更容易

---

### 第十章 - C++ Arrays

C++ Arrays

C++ Multidimensional Arrays

C++ Pointer to an Array

Size of Array parameter

Passing Arrays to Functions in C++

What is Array Decay in C++? How can it be prevented?

---

### 第十一章 - C++ Strings

C++ Strings

C++ std::string Class

C++ Array of Strings

C++ String Functions

C++ String Concatenation

Tokenizing a String in C++

C++ Substring

---

### 第十二章 - C++ Structures and Unions

C++ Structures, Unions, and Enumerations

C++ Structures

C++ Pointer to Structure

C++ Self-Referential Structures

Difference Between C Structures and C++ Structures

C++ Unions

C++ Bit Fields

C++ Enumeration

C++ typedef

Array of Structures vs Array within a Structure in C/C++

---

### 第十三章 - C++ Dynamic Memory Management

C++ Dynamic Memory Management

C++ new and delete Operators

new vs malloc() and free() vs delete in C++

Memory leak in C++

Difference between Static and Dynamic Memory Allocation in C++

---

### 第十四章 - C++ Object-Oriented Programming

C++ Object Oriented Programming (OOPs)

C++ Classes and Objects

C++ Access Modifiers

C++ Friend Class and Function

C++ Constructors

C++ Default Constructors

C++ Copy Constructor

C++ Destructors

C++ Private Destructor

When is the Copy Constructor Called?

Shallow Copy and Deep Copy in C++

When Should We Write Our Own Copy Constructor?

Does the Compiler Create a Default Constructor When We Write Our Own?

C++ Static Data Members

C++ Static Member Functions

C++ this pointer

C++ Scope Resolution Operator vs this pointer

C++ Local Class

C++ Nested Classes

C++ enum Class

Difference between Structure and Class in C++

Why C++ is a partially Object Oriented Language?

---

### 第十五章 - C++ Encapsulation and Abstraction

C++ Encapsulation

C++ Abstraction

Difference between Abstraction and Encapsulation in C++

---

### 第十六章 - C++ Polymorphism

C++ Polymorphism

C++ Function Overriding

C++ Virtual Functions and Runtime Polymorphism

Difference between Compile-time and Run-time Polymorphism in C++

Difference between Inheritance and Polymorphism in C++

---

### 第十七章 - C++ Function Overloading

C++ Function Overloading

C++ Constructor Overloading

C++ Function that Cannot be Overloaded

C++ Function Overloading and const Keyword

C++ Function Overloading and Return Type

C++ Function Overloading and float Data Type

C++ Function Overloading and Default Arguments

Can main() be overloaded?

C++ Function Overloading Vs Function Overriding

Advantages and Disadvantages of C++ Function Overloading

---

### 第十八章 - C++ Operator Overloading

C++ Operator Overloading

Types of C++ Operator Overloading

C++ Functors

C++ Operators that Cannot be Overloaded

---

### 第十九章 - C++ Inheritance

C++ Inheritance

C++ Inheritance Access

C++ Multiple Inheritance

C++ Hierarchical Inheritance

C++ Multilevel Inheritance

C++ Constructor in Multiple Inheritance

C++ Inheritance and Friendship

Does Function Overloading Work with Inheritance in C++?

Difference Between Inheritance and Polymorphism in C++

---

### 第二十章 - C++ Virtual Functions

C++ Virtual Functions

C++ Virtual Functions in Derived Classes

C++ Default Arguments and Virtual Function

C++ Inline Virtual Functions

C++ Virtual Destructor

C++ Virtual Constructor

C++ Virtual Copy Constructor

C++ Pure Virtual Functions and Abstract Class

C++ Pure Virtual Destructor in C++

Can Static Functions be Virtual in C++?

C++ RTTI (Run-Time Type Information)

Can C++ Virtual Functions be Private?

---

### 第二一章 - C++ Exception Handling

C++ Exception Handling

C++ Exception Handling using Classes

C++ Stack Unwinding

C++ User-Defined Exceptions

---

### 第二二章 - C++ Files and Streams

C++ Files and Streams

C++ I/O Redirection

---

### 第二三章 - C++ Templates

C++ Templates

C++ Template Specialization

C++ using Keyword

---

### 第二四章 - C++ Standard Template Library (STL)

The C++ Standard Template Library (STL)

STL Algorithms

STL Containers

STL Vector

STL Pair

STL Set

STL Multiset

STL Stack

STL Queue

STL Priority Queue

STL Deque

STL List

STL Forward List

STL Map

STL Multimap

STL Bitset

STL Unordered Sets

STL Unordered Multiset

STL Unordered Map

STL Unordered Multimap

---

### 第二五章 - C++ Iterators

Introduction to C++ Iterators

C++ Input Iterators

C++ Output Iterators

C++ Forward Iterators

C++ Bidirectional Iterators

C++ Random Access Iterators

C++ istream_iterator and ostream Iterator

Difference between C++ Iterators and Pointers

---

### 第二六章 - C++ Preprocessors

C++ Preprocessor

C++ Preprocessor Directives

C++ #include Directive

C++ #define Directive

C++ Conditional Preprocessors

Difference between C++ Preprocessor Directives and Function Templates

---

### 第二七章 - C++ Namespace

C++ Namespaces

Extending C++ Namespace and Unnamed Namespace

Accessing, Creating Header, Nesting, and Aliasing Namespace

C++ Inline Namespaces

---

### 第二八章 - Advanced C++

C++ Multithreading

C++ Smart Pointers

Differences between Different C++ Smart Pointers

Type of ‘this’ Pointer in C++

Delete ‘this’ Pointer in C++

Passing C++ Function as a Parameter

C++ Signal Handling

C++ Generics

---

### 第二九章 - C vs C++

Differences and Similarities between C++ and C

Difference between C++ and Objective C

C programs that won’t compile in C++

Program that produces different results in C and C++

Void \* in C vs C++

Type Difference of Character Literals in C vs C++

Difference between Structures in C and Structures in C++

Cin-Cout vs Scanf-Printf

---

### 第三十章 - C++ vs Java

Differences and Similarities between C++ and Java

Inheritance in C++ vs Java

Static keyword in C++ vs Java

Default Virtual Behavior in C++ vs Java

Exception Handling in C++ vs Java

Foreach loop in C++ vs Java

Templates in C++ vs Generics in Java

Floating Point Operations & Associativity in C, C++, and Java

---

### 第三一章 - Competitive Programming in C++

Competitive Programming – A Complete Guide

C++ Tricks for Competitive Programming

Writing C/C++ code efficiently in Competitive Programming

Why C++ is Best for Competitive Programming?

Generating Test Cases in C++

Fast I/O for Competitive Programming in C++

Setting up Sublime Text for C++ Competitive Programming Environment

Setting up VS Code for C++ Competitive Programming Environment

Which C++ libraries are useful for competitive programming?

Common mistakes to be avoided in Competitive Programming in C++

---
