## GeeksForGeeks C++ tutorial

### [Website resource](https://www.geeksforgeeks.org/c-plus-plus/), Backend/C++

---

第一章 - C++ Overview

第二章 - C++ Basics

第三章 - C++ Variables and Constants

第四章 - C++ Data Types and Literals

第五章 - C++ Operators

第六章 - C++ Input/Output

第七章 - C++ Control Statements

第八章 - C++ Functions

第九章 - C++ Pointers and References

第十章 - C++ Arrays

第十一章 - C++ Strings

第十二章 - C++ Structures and Unions

第十三章 - C++ Dynamic Memory Management

第十四章 - C++ Object-Oriented Programming

第十五章 - C++ Encapsulation and Abstraction

第十六章 - C++ Polymorphism

第十七章 - C++ Function Overloading

第十八章 - C++ Operator Overloading

第十九章 - C++ Inheritance

第二十章 - C++ Virtual Functions

第二一章 - C++ Exception Handling

第二二章 - C++ Files and Streams

第二三章 - C++ Templates

第二四章 - C++ Standard Template Library (STL)

第二五章 - C++ Iterators

第二六章 - C++ Preprocessors

第二七章 - C++ Namespace

第二八章 - Advanced C++

第二九章 - C vs C++

第三十章 - C++ vs Java

第三一章 - Competitive Programming in C++

---

### 第一章 - C++ Overview

Introduction to C++

Features of C++

History of C++

Interesting Facts about C++

Setting up C++ Development Environment

Similarities and Differences between C++ and C

---

### 第二章 - C++ Basics

First C++ Program

- Hello World Program

  ```C++
  #include <iostream>
  using namespace std;
  int main()
  {
    cout << "Hello World";
    return 0;
  }
  ```

C++ Basic Syntax

- Header File
  - 包含函式的定義 (function) 和 marcos
- Namespace
  - 用來避免 name conflicts
- Main Function
  - Function 是 C++ 最基礎的單元
  - `main` function 是最重要的起點
- Blocks
  - 由 `{}` 包裹, 用來定義 scope
- Semicolons
  - `;`, 必要的, 代表一段語法的結束
- Identifiers
  - 命名
  - 變數, 函式, 自定義資料型態
- Keywords
  - 保留字
  - 不可以做為 identifiers 使用
- Basic Output `cout`
  - `cout << variable_name;`
- Object-Oriented Programming in C++
  - C++ 支援 procedural-oriented 與 object-oriented programming 兩種範型
  - `class`
  - Data Members
  - Member Functions

C++ Comments

- 註解
- 單行註解, `//`
- 多行註解, `/* */`
- 對於 compiler
  - 註解會被 Lexical Analyzer 過濾掉

C++ Tokens

- 每個在 source code 中的 word 都是 token
- 分類
  - Identifiers
  - Keywords
  - Constants
  - Strings
  - Special Symbols
    - `;`, `[]`, `{}`, `::`, `.`, `=`, `"`, `'`
  - Operators
    - Unary Operators, `++`, `--`
    - Binary Operators
      - Arithmetic Operators, `+`, `-`, `*`, `/`, `%`
      - Comparison Operators, `==`, `!=`, `<`, `>`, `<=`, `>=`
      - Logical Operators, `&&`, `||`, `!`
      - Assignment Operators, `+=`, `-=`, `*=`, `/=`, `%=`
      - Bitwise Operators, `&`, `|`, `^`, `~`, `<<`, `>>`
    - Ternary Operators, `? : ;`

C++ Identifiers

- 獨特的命名, unique name, 來定義 variables, functions, classes, structs, ...
- 命名規則
  - 使用 `A-Z` or `a-z`, `0-9`, `_`
  - 只允許字母或底下作為開頭
  - 不允許使用保留字 (keywords)
  - 在同一個 namespace 下必須是唯一的
  - C++ 是 case sensitive, 大小寫有別

C++ Keywords

- `asm`
- `auto`
- `break`
- `case`
- `catch`
- `char`
- `class`
- `const`
- `continue`
- `default`
- `delete`
- `do`
- `double`
- `else`
- `enum`
- `extern`
- `float`
- `for`
- `friend`
- `goto`
- `if`
- `inline`
- `int`
- `long`
- `new`
- `operator`
- `private`
- `protected`
- `public`
- `register`
- `return`
- `short`
- `signed`
- `sizeof`
- `static`
- `struct`
- `switch`
- `template`
- `this`
- `throw`
- `try`
- `typedef`
- `union`
- `unsigned`
- `virtual`
- `void`
- `volatile`
- `while`

Difference between Keyword and Identifier

---

### 第三章 - C++ Variables and Constants

C++ Variables

- 變數是為一個記憶體空間的命名
- C++ 中變數必須先宣告 (declared) 才能使用
- `type variable_name;`
- 關於 Variable Scopes, 變數可被分成
  - Local Variables, 關於任何 block
  - Instance Variables, 關乎 class
  - Static Variables, 關乎 class, 使用 `static` 進行宣告

C++ Constants

- Constants, 在整個執行期都是固定的值
- Constants 在 C++ 中代表一個變數的值, 在執行期永遠不會改變
- 定義方式有以下三種
- `const`, 來自 C 語法, 在宣告變數時加上前綴 `const` 並且宣告時必須初始化
  - 初始化可以來自於 runtime 或 compile time
- `constexpr` 與 `const` 類似但是, 初始化必須在 compile time 時就知道值
- `#define` 使用 preprocessor 定義常數 (macro constants)
  - preprocessor 進行的事情只是單純的文字替換

Scope of C++ Variables

- Local Variables, 區域變數
- Global Variables, 全域變數
- 當區域變數與全域變數同名時
  - 區域變數優先於全域變數
  - 如果使用 `::` scope resolution operator 作為前綴的話, 可以取得全域變數

C++ Storage Classes

- C++ 儲存類別
- 可以指定變數的儲存類型, 會影響變數 lifetime, scope, initial value 和儲存位置
- 分成六種並且有對應的 keywords
  - auto, 預設模式
  - `register`, C++11 後 deprecated, 暗示 compiler 希望使用 CPU register 儲存
  - `extern`, 預設值為 0, 在任意地方主動定義的 global variable
  - `static`, 預設值為 0, 不會消失, 會一直存活在呼叫處, (例如, 永遠存活在該函式 body 內)
  - `mutable`, class based
  - `thread_local`, thread based, C++11 以後支援

C++ Static Variables

- `static` keyword 使用上可以分成兩種類型
  - Static Variables,
    - 像是在 function body 宣告的 static variable
  - Static Members of Class,
    - 存在 class 內, 由 objects 共享

---

### 第四章 - C++ Data Types and Literals

C++ Data Types

- 所有的變數都需要事先宣告其資料型別, 資料型別讓 compiler 決定要給予該變數多少的記憶體空間
- Data types 的類型可以分為
- Primary, Built-in, Fundamental data type
  - Integer, `int`, `short`, `long`
  - Character, `char`
  - Boolean, `bool`
  - Floating Point, `float`
  - Double Floating Point, `double`
  - Void, `void`
  - Wide Character, `wchar_t`
- Derived data types
  - Function
  - Array
  - Pointer
  - Reference
- User-defined data types
  - Class
  - Structure
  - Union
  - Enum
  - Typedef
- `sizeof()` operator, 取得變數或資料型態的記憶體大小
- Datatype Modifiers
  - Signed, `signed`
  - Unsigned, `unsigned`
  - Short, `short`
  - Long, `long`
- Macro Constants
  - `CHAR_MIN`, `CHAR_MAX`
  - `SCHAR_MIN`, `SCHAR_MAX`, `CHAR_BIT`
  - `MB_LEN_MAX`
  - `SHRT_MIN`, `SHRT_MAX`, `USHRT_MAX`, `INT_MIN`, `INT_MAX`, `UINT_MAX`, `LONG_MIN`, `LONG_MAX`, `ULONG_MAX`, `LLONG_MIN`, `LLONG_MAX`, `ULLONG_MAX`

C++ Literals

- 數值的表示, 分成
- Integer Literals, 整數
  - 沒有小數部分單純的整數, 直接以數字表達
  - 8 進位, 前綴為 `0`, 16 進位, 前綴為 `0x`, 2 進位, 前綴為 `0b`
  - 長整數 (`long int`), 後綴為 `L`, `l`
  - 無號整數 (`unsigned int`), 後綴為 `u`, `U`
  - 長整數 (`long long int`), 後綴為 `ll`, `LL`
- Floating Point Literals, 浮點數
  - `double`, 預設值, 不需要前綴或後綴
  - `float`, 後綴為 `f`
- Character Literals, 字元
  - 包裹在 `' '` 中
- String Literals, 字串
  - 包裹在 `" "` 中
- Boolean Literals, 布林值
  - `true`, `false`

C++ Derived Data Types

- Function, 函式宣告
  - `FunctionReturnType FunctionName(Parameters)`
- Array, 陣列
  - `DataType ArrayName[SizeOfArray]`
  - C++ 陣列宣告時需要提供陣列數量 (固定長度, 記憶體空間)
- Pointers, 指標
  - `DataType* VariableName`
  - 儲存指向指定資料型態的記憶體空間位置
- References, 參考
  - `DataType& ReferenceName = VariableName`
  - 其他變數的別名, (分享相同的記憶體位置)

C++ User-Defined Data Types

- 使用者定義的資料型別
- Class
  - `class ClassName {};`
  - 包含 data members 與 member functions
- Structure
  - `struct StructName {};`
  - 資料型別的聚集
- Union
  - `union UnionName {};`
  - 類似 Structure 但是內部所有的型別分享同一個記憶體空間
- Enumeration
  - `enum EnumName {};`
  - 數字 Enum
- Typedef
  - `typedef TypeName;`
  - 自行定義型別, 建立現有資料型別的別名
  - 用來提供更好的可閱讀性和移植性 (與實際資料結構有介面隔離)

C++ Data Type Ranges and Their Macros

- 使用 C++ macro constants 來取得資料型別的最大與最小值

C++ Type Modifiers

- 修改 primitive data type 的細節
- `signed`, 有號的, 代表能儲存 positive, negative, zero, 多數時候是預設值
  - 適用於 `int`, `char`
- `unsigned`, 無號的, 僅能儲存 non-negative values,
  - 適用於 `int`, `char`
- `short`, 縮小使用的記憶體空間, 也代表縮小能儲存值的範圍,
  - `short int` 等同於 `short`
- `long`, 增加使用的記憶體空間, 也代表增加能儲存值的範圍
  - `long int` 等同於 `long`
- Type Qualifiers, 控制變數值的操作行為
  - `const`, 無法被再次修改的
  - `volatile`, 向 compiler 表達, 該變數可能會被程式本體以外的因素修改, 例如 OS, hardware, ...
    - 調整 compiler 對該變數的優化選項
  - `restrict`, 針對 pointer 變數專用的 modifier,
    - 由工程師保證該 pointer 所指向的對象, 不會被其他 pointer 指向 (保證是唯一 pointer)
    - 避免某些複數個 pointer 指向相同位址的情境, 提升 compiler 優化的選項

C++ Data Type Conversion

- 資料型別轉換, 分成
- Implicit Type Conversion 隱性轉換
  - Compiler 已知的安全轉換 (不會丟失資料)
  - 所有相同的資料類別由小轉大
    - `bool` -> `char` -> `short int` -> `int` -> `unsigned int` -> `long` -> `unsigned` -> `long long` -> `float` -> `double` -> `long double`
- Explicit Type Conversion 顯性轉換
  - 使用者明確表明的型別轉換, 強制轉換, 可能會丟失資料
  - 語法 1. `(type) expression`
  - 語法 2. Cast operator `<type>`, 分成四種類型
    - Static Cast
    - Dynamic Cast
    - Const Cast
    - Reinterpret Cast

C++ Typecasting Operators

- Casting operators 四種類型
- `static_cast <NewType>`
  - Compiler time 的轉換
  - library `typeinfo` 存有函式 `typeid()` 可以協助我們確認型別資訊
- `dynamic_cast <NewType>`
  - 通常用於 Class pointer/reference 進行類別降轉, 會在 runtime 進行確認是否能安全轉換, 無法安全轉換會取得 `null` pointer 或丟出 `bad_cast_exception`
- `const_cast <NewType>`
  - 用於指向 `const` variable 的 pointer
  - 可以通過明確表明 `const_cast` 把 `const` variable pointer 轉換成可以修改值的 non-const variable pointer
  - 小心不可預期的錯誤, **不被推薦使用**
- `reinterpret_cast <NewType>`
  - 不進行任何安全確認的強制轉換
  - 小心不可預期的錯誤, **不被推薦使用**

---

### 第五章 - C++ Operators

C++ Operators

- 運算子, 分成六種
- Arithmetic Operators, 數值算子
  - 單元的, `++`, `--`
  - 雙元的, `+`, `-`, `*`, `/`, `%`
- Relational Operators, 比較算子
  - `==`, `>`, `>=`, `<`, `<=`, `!=`
- Logical Operators, 邏輯算子
  - `&&`, `||`, `!`
- Bitwise Operators, 位元算子
  - `&`, `|`, `^`, `<<`, `>>`, `~`
- Assignment Operators, 賦值算子
  - `=`,
  - `+=`, `-=`, `*=`, `/=`, `%=`,
  - `&=`, `|=`, `^=`, `<<=`, `>>=`,
- Ternary or Conditional Operators, 三元運算子, 條件算子
  - `Expression1 ? Expression2 : Expression3`

C++ Unary Operators

- 單元算子
- `++`, `--`
- `+`, `-`, 正負號
- `!`, 邏輯否定
- `~`, 位元 NOT
- `&`, 記憶體位置算子 (Address Operator)
- `*`, 取值算子 (Dereference Operator)
- `sizeof()`

C++ Sizeof Operator

- 取得記憶體大小
- `sizeof(DataType)`
- `sizeof(Expression)`

C++ Scope Resolution Operator

- `::` 範疇算子
- 可以用來在 local 取得同名的 global 變數
- 可以在 Class 外部定義, 新成員
- 取得 Class 的靜態成員 (`static`)
- 區分多重繼承 (multiple inheritance) 同名的成員
- 去調用巢狀定義 Class 的成員, (nested class)

---

### 第六章 - C++ Input/Output

C++ Basic Input/Output

- stream, 一個 bytes 的序列
- Input stream, 讀取進主記憶體 (main memory)
- Output stream, 從主記憶體輸出 (main memory) 到外部裝置
- IO 相關的 header files
  - `iostream`, 標準 IO, (`cin`, `cout`, `cerr`)
  - `iomanip`, manipulating IO, 調整 IO stream 相關的工具
  - `fstream`, 以檔案為目標的 IO
  - `bits/stdc++`, 一次讀入所有的標準函式庫, 在 CP 有時間競爭時, 可以取代一個一個輸入 header files
- C++ 中標準函式庫的 namespace 為 `std`
  - 因此會在所有的檔案中使用 `using namespace std;` 來一次性的加上前綴 `std::`
- `cout`, Standard output stream, 配合 `<<`
- `cin`, Standard input stream, 配合 `>>`
- `cerr`, Un-buffered standard error stream, 配合 `<<`
  - Un-buffered 代表會立刻發出
- `clog`, Buffered standard error stream, 配合 `<<`
  - Buffered 會先存在 buffer 中

C++ Standard Input Stream (`cin`)

- `cin` object 屬於 istream
- 單個 Input, `cin >>`
  - 多個 Input 以 `>>` 串連
- `cin.getline(char* buffer, int N)`
  - 一次讀取 `N - 1` 個字元, 或者遇到 end of file 或 newline `\n` 才停止
- `cin.get(char& var)`
- `cin.read(char* buffer, int N)`
- `cin.ignore()`

C++ Standard Output Stream (`cout`)

- `cout` object 屬於 ostream
- 單個 Output, `cout <<`
  - 多個 Output 以 `<<` 串連
- `cout.write(char* str, int n)`
- `cout.put(char& ch)`
- `cout.precision(int n)`, 控制輸出的浮點數精度

C++ Standard Error Stream (`cerr`)

- `cerr` object 屬於 ostream
- un-buffered 進行 error 輸出

C++ Input/Output Manipulator

- 對 iostream 進行控制
- Manipulators without arguments
  - `endl`, 定義在 ostream 中, 進行 new line 並且 flushes buffer
  - `ws`, 定義在 istream 中, 用來忽略 whitespaces
  - `ends`, 定義在 ostream 中, 插入 null 進入 output stream,
  - `flush`, 定義在 ostream 中, 立即清除 output stream buffer
- Manipulators with Arguments
- `iomanip` header 中的
  - `setw(val)`, width
  - `setfill(char)`, 塞入 char
  - `setprecision(val)`, 控制浮點數精度
  - `setbase(val)`, 設定數值的 base
  - `setiosflags(flag)`, 設定 format flags
  - `resetioflags(m)`, 重置 format flags
- `ios` header 中的
  - `showpos`, 強制顯示正數的 positive sign
  - `noshowpos`, 強制不顯示正數的 positive sign
  - `showbase`, 強制顯示數值的 base
  - `uppercase`, 轉換成 upper case
  - `nouppercase`, 轉換成 lower case
  - `fixed`, 使用 decimal notation 顯示浮點數
  - `scientific`, 使用科學記號的方式顯示浮點數
  - `hex`, 讀取或輸入使用 16 進位, 等同於 `setbase(16)`
  - `dec`, 讀取或輸入使用 10 進位, 等同於 `setbase(10)`
  - `oct`, 讀取或輸入使用 8 進位, 等同於 `setbase(8)`
  - `left`,
  - `right`,

---

### 第七章 - C++ Control Statements

C++ Decision Making

- conditional statements
- If Statement
  - `if (condition) {}`
  - `if (condition) {} else {}`
  - `if (condition) {} else if (condition) {} else {}`
- Switch Statement
  - `switch (expression) { case value1: break; case value2: break; default: }`
- Ternary Operator
  - `condition ? expression1 : expression2;`
- Jump Statements
  - `break`,
  - `continue`,
  - `goto`, 配合 label 進行跳躍
  - `return`,

C++ Loops

- 重複進行數次
- `for` loop,
  - `for (initialization_expression; condition; iteration_execution) {}`
  - `for (auto element:array)`, Range-Based for Loop
    - `for (auto& [key, value]: map_name) {}`
  - 使用 iterator pattern 的 for loop
    - `for_each(start_iter, last_iter, fnc)`
- `while` loop,
  - `while (condition) {}`
  - `do {} while (condition);`
- Infinite Loop
  - 沒有終止條件的 loop
  - 例如 `for(;;) {}`, `while(1) {}`

---

### 第八章 - C++ Functions

C++ Functions

- 重複的邏輯封裝成函式
- 函式宣告 `ReturnType function_name (Parameters) { function_body }`
- C++ 可以分離函式宣告 (Header) 與實作內容 (Function Body)
  - 呼叫任何函式前, 必須先有 header 被宣告或者 include
- 所有的函式都必須有 return type
- 如果沒有顯性的 `return`, function 會自動 return `void`, 等同於 `return;`
  - 因此如果沒有 return 的 function 需要使用 `void` 作為 Return Type 宣告
- Main Function
  - 程式的進入點
  - `int main() { return 0; }`, without parameters
  - `int main(int argc, char* const argv[]) { return 0; }`, with parameters
  - 回傳值 `0` 代表執行沒有問題
- Recursion
  - 函式裡面呼叫自身函式, 被稱為遞迴程式
  - 尾端遞迴 tail recursion
- Function Overloading
  - 同名異式
  - 同名函式, 但是簽名細節不同 (different parameters)

C++ Parameter Passing Techniques

- Pass by Value
  - 傳遞被複製的值作為參數
- Pass by Reference
  - 傳遞變數的地址作為參數, 函式宣告時, 使用 `&` 指定參數型別為 Reference
- Pass by Pointer
  - 傳遞 pointer 參數, 達成類似傳遞 reference 的方式進行

Difference between Call by Value and Call by Reference

- Call By Value in C
  - 是複製的值, 存放在不同的 address
- Call By Reference in C
  - 使用同一個 address

C++ Default Arguments

- 宣告時使用 `=` 在呼叫時沒有指定時提供預設值

C++ Recursion

- C++ 有 tail recursion 最佳化 (尾端遞迴最佳化)
  - 自動改寫成 loop 版本, 最佳化 memory 使用避免 stack overflow
- 遞迴的缺點
  - 效能較差 (需要 function call 造成的 overhead)
  - 空間使用效率較差 (需要 function call 造成的 overhead)
  - 不易 debug
  - 可能造成 stack overflow 導致程式崩潰

C++ Inline Functions

- 宣告函式時使用 `inline` 作為前綴 keyword 代表 inline function
- 讓 compiler 進行最佳化, 不實際實現 function 而是使用程式碼 copy 取代 function overhead
  - 使用額外的 register 去進行效能最佳化
- 使用時機只有在針對效能有極端要求, 並且 **function body 較小的時候才有優勢**
- 過多的 Inline function 會導致
  - binary code 過大, 因為有大量重複的程式碼
  - 降低 cache hit rate
  - 對於 embedded system 可能不適用, 因為 space 比 speed 更珍貴
  - 過大的 binary code 對於執行時的 main memory 是個考驗
- 在 C 中僅能使用 macro 達成類似的行為
  - 但是對於 C++ 相同情境應該優先使用 inline function 取代 macro
  - C++ 可以提供更多的 compiler time 驗證, 保證正確性

C++ Lambda Expression

- C++ 11 後提供 Lambda Expression 提供定義不需要被重用, 也沒有名稱的, 匿名 inline function
- `[ capture_clause ] (parameters) -> return_type { }`
  - return_type 不是必須的, 如果 compiler 可以推論時
- capture clause 代表呼叫外部變數時, 使用的模式,
  - 分成 `&`, 使用 reference; `=`, 使用 value

---

### 第九章 - C++ Pointers and References

C++ Pointers and References

C++ Pointers

- Pointers, 儲存記憶體位置的變數
  - `DataType* VariableName;`
  - 對變數使用 `&` 取得變數的記憶體位置
  - 使用 `*` 從記憶體位置取值
- C++ 函式參數
  - Call-By-Value
  - Call-By-Reference with a Pointer Argument
  - Call-By-Reference with a Reference Argument
- Array Name as Pointers
  - C++ 中 Array 是以 pointer 的方式實現的
  - 可以利用 Array 變數名稱取得陣列的開始位置 (即第一個元素的記憶體位置)

C++ Pointer Arithmetic

- 操作 pointer (arithmetic operations), 向前移動或向後移動記憶體位置
- `++`, `--`, `+`, `+=`, `-`, `-=`
- Difference between two pointers
- Incrementing and Decrementing Pointer in C++
  - `++`
  - `--`
  - 依據 32-bit 或 64-bit, 儲存的資料型別, 決定前後移動的距離
- Addition of Constant to Pointers, Subtraction of Constant from Pointers
  - 加 constant 代表向前幾個位置 (以資料型別 size 為單位)
  - 減 constant 代表向後幾個位置 (以資料型別 size 為單位)
- Subtraction of Two Pointers of the Same Datatype
  - 視為距離
- Comparison of Pointers
  - `==` 是否指向相同的位置
  - Comparison to NULL (`== NULL`), 得知 pointer 是否有儲存任何記憶體位置

Dangling, Void, Null, and Wild Pointers

- Dangling pointer, 指向已經清除的記憶體位置
  - De-allocation of Memory, 指向已經的記憶體位置被 `free` or `delete`
  - Function Call, 函式回傳區域變數的 pointer, 在外部時, 當函式已經執行完畢, 指向區域變數的 pointer 就成了 dangling pointer, 除非區域變數是 `static` 的
  - Variable Goes Out of Scope, 在外部調用不存在外部的變數 pointer
- Void pointer, `void*`, 一種 Pointer 的型別, 代表指向記憶體位置, 但是不知道資料型別
  - 可以指向任何記憶體位置, 但是 Void pointer 無法被 dereferenced, 除非先經過 type casting
- Null pointer, 有效但是空的位置 (nothing), `NULL` 代表 pointer 的值
- Wild pointer, 沒有初始化的 pointer, Pointer 的值可能是任何東西 (garbage value)

Applications of Pointers

- 主要用途
- Passing Arguments by Reference
  - 為了可以在函式內直接修改變數值
  - 提升效能 (空間或者時間的, 減少複製)
- For Accessing Array Elements
  - 使用 Pointer 去讀取陣列資料
- To Return Multiple Values
  - 函式回傳多個數值, 函式只能回傳單值, 因此通過回傳 Pointer 打包多個數值
- For Dynamic Memory Allocation
  - 手動的記憶體動態配置
- 實現複雜的資料結構
  - 像是 trees, graph, linked list

C++ nullptr

- 由於 `NULL` 通常是由 `void* 0` 所實現
  - 因此在型別上沒辦法正確區分 `int` 或者是 pointer
- 通過特別的 keyword, `nullptr` 與 `nullptr_t`
  - 明確指明為 Null Pointer

C++ References

- 定義型別為 Reference 代表該變數是其他變數的別名 (alias)
  - 宣告方式是 `TypeName&`
- 可能的使用時機
- Modify the passed parameters in a function
  - Call by reference
- Avoiding a copy of large structures
  - 類似使用 pointer, 提升效能
- In For Each Loop to modify all objects
  - 在 For loop 中直接修改變數值 (通過 Reference)
- For Each Loop to avoid the copy of objects
  - 在 For loop 物件結構時, 避免複製, 使用 Reference 取代值的複製
- Reference 與 Pointer 的比較
  - Pointer 可以是 Void, 但是 Reference 不行
  - Pointer 可以是多層的 (像是 pointer of pointer), Reference 永遠只有一層 (必須指向一個值, 不能是記憶體位置)
  - Reference variable 無法被重複賦值, 必須被初始化的
  - Reference variable 不能是 NULL
  - Reference variable 是 internal pointer 實現的, (可以視為 pointer 的語法糖)
- 使用 Reference 的優點是
  - 比起 Pointer 有更多限制, 因此更安全
  - 比起 Pointer 需要進行 dereference, Reference variable 使用起來更容易

---

### 第十章 - C++ Arrays

C++ Arrays

- Array 是儲存相同資料型別的連續記憶體位置
- Array 宣告後則大小固定
- 宣告方式, `DataType ArrayName[SizeOfArray];`
- 初始化
  - `DataType ArrayName[SizeOfArray] = {};`, 填入初始值, 允許 partial, 其他值會自動預設為 0
  - `DataType ArrayName[] = {};`, 不指定數量, 而是藉由初始化值決定陣列大小
  - 使用迴圈初始化
  - 初始化為 0, 可以使用 `{0}` 賦值
- 陣列取值與賦值
  - `[]`, 配合 index
- 走訪 Array
  - 傳統 for loop
- Array 與 Pointer
  - 以 Array 名稱取值, 等同於取得第一個元素的記憶體位置, 也代表陣列的初始位置
  - 可以通過 pointer 計算取得 Array 元素值
- Passing Array to Function in C++, 陣列傳遞給函式的方式
  - 由於 Array 在 C++ 中是以 pointer 的方式存在
  - 宣告成 `DataType* ArrayName`, 明確標示為指標 (pointer)
  - `DataType ArrayName[]`, 不定大小的陣列
  - `DataType ArrayName[SizeOfArray]`, 固定大小的陣列
  - 可能會遇到 Array Decay 問題, 傳遞時遺失陣列大小資訊

C++ Multidimensional Arrays

- 多為一個維度的陣列稱為 multidimensional array 多維陣列
- 多維陣列資料仍然是以連續的記憶體來儲存
- 宣告為 `DataType ArrayName[Size1][Size2]...[SizeN];`
- 實字初始化方式分成兩種
  - 使用 `{}` 視唯一為陣列一次列完
  - 使用 nested `{}` 表達多維陣列
- 使用迴圈進行初始化
- 取值與賦值 `[][]...[]` 多層 index 指定

C++ Pointer to an Array

- `DataType* = ArrayName`
- `DataType (*PointerName)[ArraySize] = &ArrayName`
- 二維陣列
  - Array[i][j] 等同於 `*(*(Array + i) + j)`
  - 同等方式延伸到更高維度

Size of Array parameter

- 在已知陣列大小的 scope 中的 `sizeof` 與只持有陣列 pointer 的 scope `sizeof` 會取得不同的大小資訊
  - 即 Array Decay 問題
- 不要使用 `sizeof` 來判斷 array length
- 如果函式預先知道固定大小的陣列時, 使用 Reference 宣告, `FunctionName( DataType (&ArrayName)[SizeOfArray] )`
- 不知道大小的 Array 應該使用 `template` 實現動態取得
  - ```c++
    template <size_t n>
    ReturnType FunctionName(DataType (&ArrayName)[n])
    ```
  - ```c++
    template <typename T, size_t n>
    ReturnType FunctionName(T (&ArrayName)[n])
    ```

Passing Arrays to Functions in C++

- 在使用未知陣列大小的宣告方式, 需要一並傳入陣列大小做為另外一個參數

What is Array Decay in C++? How can it be prevented?

- Function 傳入以 pointer 為方式傳入 array 時, 會遺失陣列的大小資訊, 因為傳入的 pointer 僅僅是指向陣列第一個元素的指標
  - 稱之為 Array Decay
- 傳統上的解法是, 明確的傳入陣列大小資訊作為另一個參數
- 另一個解法是, 以 Reference 傳入取代 Pointer
  - 需要應對不定大小的陣列時, 仍然需要配合 `template` 使用

---

### 第十一章 - C++ Strings

C++ Strings

- String 在 C++ 中只是連續的字元, 即字元陣列
- 有兩種風格的工具可以使用
  - `std::string` class, C++ 風格
  - character array, C 風格
- C Style Strings
  - 單純的字元陣列, 並且使用 `\0` 字元作為字串終止
  - `char str[] = "Hello World"`, 單純使用陣列方式定義字串
- `std::string` Class
  - C++ 中使用 `<string>` header 引入, 封裝成物件版的字串
  - `std::string str("Hello World");`
  - `std::string str = "Hello World";`
  - `std::string str(number, character);`
- String input
  - `cin >> str;`
  - `getline(cin, str);`
  - `stringstream stringstream_object(string_name);`
- Pass Strings to Functions
  - `string str`
  - Character pointer 或陣列模式

C++ std::string Class

- `std::string` Class
  - 記憶體動態配置
  - 不會造成 array decay
  - 效能上較差
  - 內建多個函式, 協助操作
- Character Array
  - 記憶體靜態配置 (傳統的 array)
  - 有可能產生 array decay (陣列 pointer 產生的問題)
  - 效能上較佳
  - 沒有任何內建函式協助操作
- C++ String Functions
  - `length()`
  - `swap()`
  - `size()`
  - `resize()`
  - `find()`
  - `push_back()`
  - `pop_back()`
  - `clear()`
  - `strncmp()`
  - `strncpy()`
  - `strcat()`
  - `replace()`
  - `substr()`
  - `compare()`
  - `erase()`
- C++ String Iterator
  - `string::iterator`
  - `string:reverse_iterator`
  - `begin()`
  - `end()`
  - `rfind()`
  - `rbegin()`
  - `rend()`
  - `cbegin()`
  - `cend()`
  - `crbegin()`
  - `crend()`
- C++ Capacity Functions
  - `length()`
  - `capacity()`
  - `resize()`
  - `shrink_to_fit()`

C++ Array of Strings

- 建立 string array
  - 在 C 中, string array 即二維度的字元陣列
- C ways
  - Using Pointers, `const char* strings[] = { "hello", "world" };`
  - Using a 2D array, `char strings[2][6] = { "hello", "world" };`
- C++ ways
  - Using the String Class, `#include <string>`,
    - `std::string strings[2] = { "hello", "world" }`
  - Using the Vector Class, `#include <string>`, `#include <vector>`
    - C++11 以後支援
    - `std::vector<std::string> strings("hello", "world");`
    - 動態配置記憶體
  - Using the Array Class, `#include <string>`, `#include <array>`
    - `std::array<std::string, 2> strings("hello", "world");`
    - 靜態配置記憶體

C++ String Functions

- `std::string` class, 在 C++98 以後支援
- String Length
  - `length()`, `size()`
- Accessing Characters
  - Indexing, `at()`
- Appending and Concatenating Strings
  - `+`, `append()`
- String Comparison
  - `==`, `compare()`
- Substrings
  - `substr()`
- Searching
  - `find()`
- Modifying Strings
  - `replace()`, `insert()`, `erase()`
- Conversion
  - `c_str()`

C++ String Concatenation

- `append()`
- `+`
- `strcat()`
- loop

Tokenizing a String in C++

- 以指定的 delimiters 進行字串分解
- 使用 `stringstream` 配合 `getline()` + loop 手動進行
- `strtok()`, `char* strtok(char str[], const char* delims)`
- `strtok_r()`, `char* strtok_r(char* str, const char* delim, char** saveptr)`
- `std::sregex_token_iterator`

C++ Substring

- `substr()`, `string substr(size_t pos, size_t len)`

---

### 第十二章 - C++ Structures and Unions

C++ Structures, Unions, and Enumerations

- Structure,
  - 使用者定義的資料型別 (user-defined data type)
  - 常用於組合多種不同的資料型別
  - `struct StructureName {};`
- `typedef` 為已經存在的 data type 進行重新命名
  - `typedef DataTypeDefinition NewDataTypeName;`
- Union,
  - 類似於 Structure 也是使用者定義資料型別
  - 但是不同之處在於 Union 內部所定義的資料型別全部共享同一個記憶體空間
  - 使用時機在於, 在未知的情況下打包所有可能的資料型別
  - `union`
- Enum,
  - `enum`
  - 數字 enum

C++ Structures

- ```struct structureName {
    member1;
    member2;
    ...
    memberN;
  };
  ```
- C++ 中的 structure 可以定義 data member 與 member function
  - C 的 structure 無法定義 member function
- Structure Members 在 C 中無法預先定義初始化值 (compiler error)
  - 但是在 C++ 中是允許的
- 建立時同時初始化可以使用 `{}` 語法依序包裹初始值 (如同陣列一樣)
- Access structure elements
  - `.` 使用 dot operator 進行選取成員 (member)
- 如同 primitive data types 一樣
  - 可以建立 array of structures

C++ Pointer to Structure

- 如同 primitive data types 一樣
  - 可以使用 pointer
- 使用 structure pointer 時, 可以使用 `->` operator 來 access members

C++ Self-Referential Structures

- 自我參照的 structures
- 例如, linked list node 的結構中, 會有一個 link 為 `node*` 引用到自身結構定義
- 使用時必須小心的初始化, 因為 pointer 預設值會是 garbage value
- 常用於建立複雜的資料結構

Difference Between C Structures and C++ Structures

- C, C++ 的 structure 有明顯的差別
- C
  - 無法定義 member function
  - 無法使用 static member
  - 沒有 constructor function
  - 無法預設初始值
  - 必須使用 `struct` keyword
  - 沒有 access modifiers (`private`, `public`, `friend`)
  - 只存在使用 pointer
  - `sizeof` 空的 structure 會是 `0`
  - 無法做到隱藏資料實作 (data hiding)
- C++
  - 允許定義 member function
  - 允許存在 static member
  - 可以使用 constructor function
  - 可以設定初始值
  - `struct` keyword 可省略
  - 支援 access modifiers
  - 允許使用 pointer 與 reference
  - `sizeof` 空的 structure 會是 `1`
  - 可以隱藏資料實作細節 (data hiding)

C++ Unions

- Union 的記憶體空間取決於其中最大的 data member type
- 因為共用記憶體空間, 因此如果對於其他的 data member 賦值, 會覆蓋舊的內容
- 使用時機,
  - 對於 memory 有限制時的優化方式之一
  - 最佳化效能
- Anonymous Unions
  - `union {};`
  - 用這種方式定義的 data member 可以直接使用定義名稱來 access
  - 優化記憶體空間使用的情境, 允許重用相同的空間來建立不同的資料型別

C++ Bit Fields

- C++ 中的 feature
- 可以調整控制 structure 和 class members 的記憶體大小
  - 用來縮小或放大記憶體大小, 來符合使用情境, 從而達到記憶體使用最佳化
- 在宣告的後面加上 `: size_of_bits`
- 通過 bit fields 控制後, 就無法使用 pointer 與 reference 的功能

C++ Enumeration

- `enum` 預設是數字 enum 從 `0` 開始
- 定義時可以手動指定 enum 的數字值

C++ typedef

- `typedef <current_name> <new_name>`
- 用來重新命名已經存在的資料型別 (別名)
- 不要無意義的使用
- 可以應用在任何的資料型別上
  - 包含 stl templates, array, pointer
  - 因此可以利用 function pointer 建立 function 的別名

---

### 第十三章 - C++ Dynamic Memory Management

C Dynamic Memory Management

- Dynamic Memory Allocation, 在 Runtime 的時候動態調整資料結構的記憶體大小
- C ways, 屬於 `<stdlib.h>`
  - `malloc()`, memory allocation,
    - 動態規劃指定的記憶體大小 (bytes), 回傳 `void*` 指向這塊記憶體空間, 不會自動初始化, 因此預設值會是 garbage values
    - 如果生成失敗會回傳 `NULL` pointer
  - `calloc()`, continuous allocation,
    - 類似於 `malloc()` 但是會自動補上預設值 `0`, 並且是雙參數的, number of elements 與 element size in bytes
    - 生成失敗也會回傳 `NULL` pointer
  - `free()`, de-allocate,
    - `free(ptr);`, 使用 `malloc()` 與 `calloc()` 配置的記憶體並不會自己釋放, 需要在用不到的時候主動呼叫 `free()` 來釋出記憶體空間
  - `realloc()`, re-allocation,
    - 再次動態調整已經通過 `malloc()` 或 `calloc()` 建立出來的記憶體空間
    - 預設值會是 garbage values 並且如果失敗時會回傳 `NULL` pointer

C++ new and delete Operators

- 使用者動態配置的記憶體會佔用 **Heap** 空間,
- non-static local variables 則是佔用 **Stack** 空間
- C++ ways
  - `new` operator,
    - 指定的不是記憶體空間大小, 而是資料型別, 包含所有內建的資料型別和使用者定義資料型別
    - `pointer-variable = new data-type;`,
    - 如果空間足夠會建立記憶體空間並且初始化 (需要有對應的 constructor function)
    - 失敗時, 會丟出例外或者使用 `new(nothow)` 回傳 `NULL` pointer
  - `delete` operator,
    - 釋出記憶體空間
    - `delete pointer-variable;`
- Normal Array vs Using `new`
  - 主要差別在於 Normal Array 由 compiler 進行 de-allocation 的工作
  - Using `new` 記憶體的釋放必須由使用者主動觸發

new vs malloc() and free() vs delete in C++

- `new`
  - 會呼叫 constructor function
  - 僅能在 C++ 中使用
- `malloc()`
  - 不會呼叫 constructor function
  - 在 C 和 C++ 中皆能使用
- `delete`
  - 會呼叫 destructor function
  - 僅能在 C++ 中使用
- `free()`
  - 不會呼叫 destructor function
  - 在 C 和 C++ 中皆能使用

Memory leak in C++

- 在動態配置記憶體後, 忘記釋放, 會導致 memory leak
- Memory leak 會讓記憶體不斷的上升到佔滿為止
- Avoid memory leak
  - 使用 smart pointer 非不得已不要手動管理記憶體
  - 使用 `std:string` 取代 `char*`
  - 永遠不要使用 raw pointer 除非用於舊的 library 中
  - 越少使用 `new` 與 `delete` 越好, 最好完全不使用
  - 撰寫 `new` 時, 必須成對的同時一起撰寫 `delete`

---

### 第十四章 - C++ Object-Oriented Programming

C++ Object Oriented Programming (OOPs)

- OOP, 物件導向程式設計, 把資料 (data) 與行為 (function) 封裝在一起
- Class
  - 使用者定義的資料型別, 包含 data members 與 member functions
  - 是 Object 的藍圖
- Objects
  - Class 的實體
  - 物件之間通過函式溝通, 並不需要知道對方的資料細節 (data) 與實作
- Encapsulation
  - 封裝, 打包資料 (data) 或資訊 (information) 成為一個獨立的單元 (single unit)
  - 在 C++ 物件導向中通常封裝成 Class 的形式
  - 實現 data abstraction (data hiding)
- Abstraction
  - Data abstraction, 只顯示必要的資訊, 隱藏其他細節
  - Abstraction using Classes, (通過 Class 的封裝)
  - Abstraction in Header files, (通過 Function 的封裝)
- Polymorphism
  - 同名異式
  - C++ 支援兩種 Overloading
  - Operator Overloading
  - Function Overloading
- Inheritance
  - Class 之間的重用方式之一, 繼承
  - Sub Class (Derived Class)
  - Super Class (Base Class)
  - Reusability
- Dynamic Binding
  - 在 Runtime 才決定呼叫的函式實體
  - 相反的是 Static binding (在 build time (compiler time), 就進行 function call 的連結)
  - Virtual funcitons
- Message Passing
  - Object 之間的資訊傳遞

C++ Classes and Objects

- ```c++
  class ClassName
  {
    Access Specifiers /* private:, public: or protected: */
    Data members;
    Member Functions () {};
  };
  ```
- Declaring Objects
  - `ClassName objectName;`
- 使用 `.` operator 去 access data members 與 member functions
- Member Functions in Classes
  - 使用 `::` scope resolution operator 在 Class 外部定義 member functions
- `friend` function
- Constructors, 建構子
  - Class 的特殊 member function, 與 Class 同名
  - 會在每次 object 被實體化的時候呼叫
  - Default Constructors, 無參數的 constructor function
  - Parameterized Constructors, 有參數的 constructor function
  - Copy Constructors, 建立在其他 object 的資料複製之上, 參數為 class reference
- Destructors, 解構子
  - Class 的特殊 member function, 與 Class 同名, 加上前綴 `~`
  - 在 Object 的 Scope 結束時會被呼叫
- Interesting Fact (Rare Known Concept)
- Class 宣告後面的 `;`
  - Class 的定義可以像是 structure 和 union 一樣, 定義的時候同時實體化一個 object

C++ Access Modifiers

- OOP 的一個重點在於 data hiding
- 因此需要通過 access modifier 進行權限控制
- `private`, 在沒有提供 access modifier 時的預設值
  - 不公開對外, 只允許在同一個 class 內部呼叫
  - 違反的話會丟出 compile time error
- `public`
  - 在 public 之下的所有 members 允許任何人讀取, 呼叫, (公開對外的)
- `protected`
  - 類似 `private` 不公開對外
  - 但是允許所有的 subclass (Inheritance, 繼承) access

C++ Friend Class and Function

- Friend Class
  - `friend class ClassName;`
  - friend class 有權限讀取 `private` members
- Friend Function
  - `friend Function Declartion`
  - friend function 有權限讀取 `private` members
  - 可以是任意 global function
  - 也可以是其他 class 的 member functions, 此時宣告時需要使用 `::` scope operator 標註 class
- Friend function 允許 class 自身 member functions 以外的函式有能力讀取 private members
- Advantages
  - 允許在不使用繼承的情況下來重用函式
  - 可以通過 friend function 的方式來連接兩個 class 的 private data
- Disadvantages
  - 破壞了 data hiding 機制
  - 無法在 Runtime 進行 polymorphism 機制
- Important Points
  - Friends 機制應該只有很少的使用時機, 應該盡可能地不要破壞封裝
  - Friends 機制不會被繼承

C++ Constructors

- 沒有 return value, 因此不需要 return type
- 在 object 建立的時候會自動被呼叫
- 允許被 overloaded
- Constructor 是與 Class 同名的特殊函式
  - `ClassName () {};`
  - 一樣可以使用 class `::` scope operator 在外部定義
- 四種類型的 Constructors
- Default constructor
  - 無參數的 constructor
- Parameterized constructor
  - 帶有參數的 constructor
  - 使用無參數的方式建立 Object 時, 如果只有 Parameterized constuctor 的定義時會丟出 compile error
  - 因此, 無論如何明確定義一個 default constructor 被視為一個 best practice
- Copy constructor
  - 建立在另一個同 class 的物件實體所擁有的資料上
  - 參數是 class reference, `ClassName (ClassName& obj) {};`
  - **預設 compiler 會自動生成 implict copy constructor**
  - 明確定義的 copy constructor 提供進行 deep copy 和調整數值的機會
- Move constructor
  - 新的一種 constructor 類似於 copy constructor
  - 取代 copy constructor 進行資料的複製, move constructor 使用相同的記憶體空間, 只是進行 ownership 的轉移
  - `ClassName (ClassName&& obj) {}`
  - 作為效能提升的一種方式
- Compiler 會自動預設生成的函式
  - Default Constructor
  - Copy Consturctor
  - Move Constructor
  - Assignment Operator
  - Destructor
- 允許存在 private constructor
- 因為 constructor 允許 overloading
  - 因此可以定義多個 constructor

C++ Copy Constructor

- 初始化時使用到相同 Class 的其他物件
- 因此 Copy Constructor 的參數會是 Object Reference,
  - `ClassName (ClassName& object) {}`
- 觸發時機有兩種
  - `ClassName object2 = object1;`
  - `ClassName object2(object1);`
- Compiler 會預設定義 copy constructor (implicit)
- 使用者自定義 copy constructor 提供進行 deep copy 的機會 (explicit)
- 可以定義 `private` copy constructor 來讓 class non-copyable

C++ Destructors

- 在 object 離開 scope 時會自動呼叫
- 與 Class 同名, 加上前綴 `~` 的無參數無回傳值的函式
  - `~ClassName () {}`
- Destructor function 也可以被直接呼叫使用
  - `objectName.~ClassName()`

C++ Private Destructor

- `private` destructor 是允許的
- 代表 object 生成與結束都必須由使用者自行控制 (`new`, `delete`, `malloc`, `free`)
- `private` destructor 的觸發時機
  - 使用者手動觸發 `delete` 或 `free` 時
  - 這樣的呼叫可以是在任何地方, 像是另一個 public member function 甚至是 friend function

Does the Compiler Create a Default Constructor When We Write Our Own?

- No, 如果使用者已經有自定義的 constructor 時, compiler 不會再自動生成 default constructor
  - 因此如果是使用者自定義 parameterized constructor 時, 也建議自行補上 default constructor 來處理無參數呼叫時的情境

C++ Static Data Members

- `static` data member,
  - 整個 class 只有一份, 因此所有的 object 共享
  - 在任一個 object 生成時, class 就會建立該 static member
- 對於整個程式而言, class `static` data member 就是 global variable

C++ Static Member Functions

- 如同 `static` data member 一樣, 一個 class 只有一份, 並且共享, 允許獨立呼叫
- class `static` member 通常用於讓同個 class 的 objects 共用資訊

C++ this pointer

- `this` 指向 object 自身
  - 因此, static member function 無法使用 `this` pointer, 因為它隸屬於 class 而非 object
- 當 local variable 與 class data member 時, 以 `this` pointer 來提供區別
- 讓 member function 回傳值為 `ClassName&` 並且 `return *this;`
  - 來實現 chain function call
- 客製化 member functino 來實現 `delete this`
- 改變 `this` 來調整 ownership

C++ Scope Resolution Operator vs this pointer

- `::` scope resolution operator
  - 用來指向 class 本身
- `this` pointer
  - 用來指向 object 本身

C++ Local Class

- 當 class 定義在一個 function 內, 形成 local class
- Local class
  - 允許 static member function, 但是不允許 static data member
  - 讓 class 形成 scope, 只能在 scope 中使用
  - member 的定義必須是 inside class 的定義方式, 無法使用 outside define

C++ Nested Classes

- 在 class 中, 再定義另一個 class 形成 nested class

C++ enum Class

- 原始的 `enum` type 有一些限制
  - 像是 enum 的值會佔用 local variables 命名
- Enum Class
  - C++11 之後支援
  - 定義方式, `enum class Name { Value1, Value2, ... ValueN };`
  - 初始化, `EnumClassName objectName = EnumClassName::Value;`
  - 必須使用 Enum Class Name + `::` 形成 namespace
  - 允許使用 `:` 進行 Bit Field 設定儲存空間大小

Difference between Structure and Class in C++

- 在 C++ 中 Structure 與 Class 幾乎相同只有小差異
- 主要的差異在於 data hiding, access 的權限控管
  - Class 預設是 private
  - Structure 預設是 public

Why C++ is a partially Object Oriented Language?

- OOP 最重要的三個 features
  - Inheritance
  - Polymorphism
  - Encapsulation
- 對於 full OOP language 來說, 所有的內容都可以使用這三個 features
  - 例如 Java
- 因此 C++ 被認為是 partially OOP lanague
  - Main function 不是 class 的一部分
  - 有 global variable 的存在
  - Friend function 存在, 破壞封裝

---

### 第十五章 - C++ Encapsulation and Abstraction

C++ Encapsulation

- 封裝, 在 OOP 中是把 data 與操控 data 的 functions 聚合在一起
- Data Protection, 通過 class 的保護機制, 讓 private data 不會被外界所觸碰
- Information Hiding, 隱藏內部實作, 而是把 function 作為對外的接口
- 封裝有助於提升可閱讀性 (readability), 可維護性 (maintainability), 與安全性 (security)
- 為了實現好的封裝, 需要正確的使用 access specifiers
  - Private, 私有的, 只能由同個類別的內部成員觸碰 (class 的預設值)
  - Protected, 同類別或其延伸類別的
  - Public, 對外任意使用的

C++ Abstraction

- 通過 encapsulation 產生隱藏資料細節, 只對外暴露必要資訊
  - Data abstraction
  - Control abstraction
- Abstraction using Classes, 通過類別實現
  - Abstraction using Access Specifiers
- Abstraction in Header files, 通過函式實現
- 提升 abstraction 的好處
  - 避免使用者需要撰寫 low-level code
  - 避免重複的程式碼, 提高重用性
  - 調整內部實作不會影響外部的使用者 (介面隔離)
  - 提升安全性, 避免重要資訊對外暴露
  - 降低複雜度, 增加可閱讀性

---

### 第十六章 - C++ Polymorphism

C++ Polymorphism

- Compile-time polymorphism
  - Function overloading,
    - 同名異式, 相同的函式名稱不同的 arguments 宣告, 對應不同的函式實體
  - Operator overloading
    - 相同的 operator 符號, 但是不同的功能, 自行定義功能細節
- Runtime polymorphism
  - Function overriding,
    - Derived class override 相同名稱的函式, 產生不同的實作細節, Runtime 時依據不同的 object 呼叫不同的實作
  - Virtual functions
    - `virtual` keyword, 定義
    - 在 Runtime 時, 才有 child class 的 function overriding 決定呼叫的函式實體為誰
- Runtime 與 Compile-time 的差異在於, 何時進行 binding

C++ Function Overriding

- Call overriden function from derived class
  - 在 derived class 進行 function overriding 時, 可以通過 `::` operator 去呼叫父層的 function
  - 可以避免重複的程式碼
- Call overriden function using pointer
  - 利用 `ParentClass*` 作為型別, 由 `&ChildObject` 轉換之後使用 pointer `->` 即可呼叫父層的 function
- Access of Overriden Function to the Base Class
  - Child Object 使用 `.ParentClass::` 也可以呼叫父層函式

C++ Virtual Functions and Runtime Polymorphism

- Virtual function, 在 parent class 的 member function 並且使用 `virtual` keyword 標註
  - 必須在 child class 進行 overriding
  - `virtual` keyword 讓 compiler 知道, function binding 需要在 runtime 時才決定 (Runtime polymorphism)
- 一般而言 (沒有 `virtual` 的 function overriding) 使用 parent class pointer 呼叫的 function 會是 parent function, 儘管 object 是 child class 生成的
  - `virtual` function 在使用 parent class pointer 時, 仍然可以在 runtime 呼叫正確的 child function

---

### 第十七章 - C++ Function Overloading

C++ Function Overloading

- 同名異式, same name different parameters
- 主要用於提昇可閱讀性和支援更多情境
- C++ Constructor Overloading

C++ Function Overloading and const Keyword

- 在 class 中 member function 名稱與參數完全一樣, 但是其中一個有 `const` keyword 結尾
- 對應到使用 `const` 宣告的物件, 呼叫時的 member function overloading
- 無關物件的 function overloading with `const` parameter

C++ Function Overloading and float Data Type

- Function overloading 的一個重點在於, 必須讓 compiler 有辦法決定誰該被執行, 不能有歧異 (ambiguous)
- 要小心 floating literals 是被視為 `double` 而非 `float`
- 因此使用 literals 時需要配上 `f` 提示 compiler

---

### 第十八章 - C++ Operator Overloading

C++ Operator Overloading

- Compile-time polymorphism
- 為現有的 operator 賦予其他意義
- `+` operator overloading, `ClassName opeartor+ (ClassName const& object)`
- operator function, 與其他 function 一樣, 只是使用 `operator` keyword 作為前綴
- 大多數的 operator 皆可以 overloading
- 以下幾個是少數不可以進行 opeartor overloading 的案例
  - `sizeof`, `typeid`,
  - Scope resolution `::`
  - Class member access operators, `.`, `.*`
  - Conditional operator, `?:`

C++ Functors

- Functor, 在 C++ 中是以 Class 的方式實現
- 建立 Class 並且 overload, `operator ()` 來實現函式的函式
  - 利用 Class 來實現一個函式的功能
- C++ Functor 通常用於 STL 中

---

### 第十九章 - C++ Inheritance

C++ Inheritance

- `class <derived_class_name> : <access-specifier> <base_class_name> {}`
  - `class ABC : private XYZ`, `class ABC : XYZ` 預設值
  - `class ABC : public XYZ`
  - `class ABC : protected XYZ`
- `private` derivation
  - 代表 parent class 的所有 member (包含 public member) 對於 child class 來說都是 private 的
  - 即無法通過 child class 直接呼叫 parent class 的任何 member
- `public` derivation
  - 代表 parent class 的 public member 會自動變成 child class 的 public member
  - 即可以通過 child class 直接呼叫 parent class 裡的 public members
- Types of inheritance
- Single inheritance
  - 只繼承一個 base class
- Multiple inheritance
  - 同時繼承多個 base classes
- Multilevel inheritance
  - 多層的繼承, 代表有父 class, 子 class, 孫 class 之間都有繼承關係
- Hierarchical inheritance
  - 存在繼承樹
- Hybrid inheritance
  - 同時符合數個以上四種類型的繼承
- 避免 ambiguity 的兩種方法
  - 使用 scope resolution operator `::` 明確標注
  - 使用 `virtual` base class

C++ Inheritance Access

- 以 inheritance acces base class 為分類
- 分成三種類型
  - `private` inheritance, 預設行為,
  - `public` inheritance ,
  - `protected` inheritance,

C++ Multiple Inheritance

- C++ 中允許多重繼承
- 然而多重繼承會遇到 diamond problem 產生的 ambiguity
  - 兩個父層 class 繼承同一個爺層 class 因此子層 class 會擁有超過一組以上的爺層 class member 與執行
  - 解決方案是在父層 class 使用 `virtual` 繼承爺層 class

C++ Hierarchical Inheritance

- 由 base class 開始形成的繼承樹 (tree)

C++ Multilevel Inheritance

- 多於一層以上的繼承關係

C++ Inheritance and Friendship

- 因為 friend function 並不是 member 因此不會通過繼承關係被繼承

Does Function Overloading Work with Inheritance in C++?

- function overloading 並**不會作用**在 inheritance 上
  - 即父層與子層有類似 function overloading 的函式定義並不會透過 inheritance 實現 function overloading
- 然而這件事情在 Java 是會運作的, 即可以通過 inheritance 實現 function overloading

---

### 第二十章 - C++ Virtual Functions

C++ Virtual Functions

C++ Virtual Functions in Derived Classes

C++ Default Arguments and Virtual Function

C++ Inline Virtual Functions

C++ Virtual Destructor

C++ Virtual Constructor

C++ Virtual Copy Constructor

C++ Pure Virtual Functions and Abstract Class

C++ Pure Virtual Destructor in C++

Can Static Functions be Virtual in C++?

C++ RTTI (Run-Time Type Information)

Can C++ Virtual Functions be Private?

---

### 第二一章 - C++ Exception Handling

C++ Exception Handling

C++ Exception Handling using Classes

C++ Stack Unwinding

C++ User-Defined Exceptions

---

### 第二二章 - C++ Files and Streams

C++ Files and Streams

C++ I/O Redirection

---

### 第二三章 - C++ Templates

C++ Templates

C++ Template Specialization

C++ using Keyword

---

### 第二四章 - C++ Standard Template Library (STL)

The C++ Standard Template Library (STL)

STL Algorithms

STL Containers

STL Vector

STL Pair

STL Set

STL Multiset

STL Stack

STL Queue

STL Priority Queue

STL Deque

STL List

STL Forward List

STL Map

STL Multimap

STL Bitset

STL Unordered Sets

STL Unordered Multiset

STL Unordered Map

STL Unordered Multimap

---

### 第二五章 - C++ Iterators

Introduction to C++ Iterators

C++ Input Iterators

C++ Output Iterators

C++ Forward Iterators

C++ Bidirectional Iterators

C++ Random Access Iterators

C++ istream_iterator and ostream Iterator

Difference between C++ Iterators and Pointers

---

### 第二六章 - C++ Preprocessors

C++ Preprocessor

C++ Preprocessor Directives

C++ #include Directive

C++ #define Directive

C++ Conditional Preprocessors

Difference between C++ Preprocessor Directives and Function Templates

---

### 第二七章 - C++ Namespace

C++ Namespaces

Extending C++ Namespace and Unnamed Namespace

Accessing, Creating Header, Nesting, and Aliasing Namespace

C++ Inline Namespaces

---

### 第二八章 - Advanced C++

C++ Multithreading

C++ Smart Pointers

Differences between Different C++ Smart Pointers

Type of ‘this’ Pointer in C++

Delete ‘this’ Pointer in C++

Passing C++ Function as a Parameter

C++ Signal Handling

C++ Generics

---

### 第二九章 - C vs C++

Differences and Similarities between C++ and C

Difference between C++ and Objective C

C programs that won’t compile in C++

Program that produces different results in C and C++

Void \* in C vs C++

Type Difference of Character Literals in C vs C++

Difference between Structures in C and Structures in C++

Cin-Cout vs Scanf-Printf

---

### 第三十章 - C++ vs Java

Differences and Similarities between C++ and Java

Inheritance in C++ vs Java

Static keyword in C++ vs Java

Default Virtual Behavior in C++ vs Java

Exception Handling in C++ vs Java

Foreach loop in C++ vs Java

Templates in C++ vs Generics in Java

Floating Point Operations & Associativity in C, C++, and Java

---

### 第三一章 - Competitive Programming in C++

Competitive Programming – A Complete Guide

C++ Tricks for Competitive Programming

Writing C/C++ code efficiently in Competitive Programming

Why C++ is Best for Competitive Programming?

Generating Test Cases in C++

Fast I/O for Competitive Programming in C++

Setting up Sublime Text for C++ Competitive Programming Environment

Setting up VS Code for C++ Competitive Programming Environment

Which C++ libraries are useful for competitive programming?

Common mistakes to be avoided in Competitive Programming in C++

---

```

```

```

```
