## GeeksForGeeks C++ tutorial

### [Website resource](https://www.geeksforgeeks.org/c-plus-plus/), Backend/C++

---

第一章 - C++ Overview

第二章 - C++ Basics

第三章 - C++ Variables and Constants

第四章 - C++ Data Types and Literals

第五章 - C++ Operators

第六章 - C++ Input/Output

第七章 - C++ Control Statements

第八章 - C++ Functions

第九章 - C++ Pointers and References

第十章 - C++ Arrays

第十一章 - C++ Strings

第十二章 - C++ Structures and Unions

第十三章 - C++ Dynamic Memory Management

第十四章 - C++ Object-Oriented Programming

第十五章 - C++ Encapsulation and Abstraction

第十六章 - C++ Polymorphism

第十七章 - C++ Function Overloading

第十八章 - C++ Operator Overloading

第十九章 - C++ Inheritance

第二十章 - C++ Virtual Functions

第二一章 - C++ Exception Handling

第二二章 - C++ Files and Streams

第二三章 - C++ Templates

第二四章 - C++ Standard Template Library (STL)

第二五章 - C++ Iterators

第二六章 - C++ Preprocessors

第二七章 - C++ Namespace

第二八章 - Advanced C++

第二九章 - C vs C++

第三十章 - C++ vs Java

第三一章 - Competitive Programming in C++

---

### 第一章 - C++ Overview

Introduction to C++

Features of C++

History of C++

Interesting Facts about C++

Setting up C++ Development Environment

Similarities and Differences between C++ and C

---

### 第二章 - C++ Basics

First C++ Program

- Hello World Program

  ```C++
  #include <iostream>
  using namespace std;
  int main()
  {
    cout << "Hello World";
    return 0;
  }
  ```

C++ Basic Syntax

- Header File
  - 包含函式的定義 (function) 和 marcos
- Namespace
  - 用來避免 name conflicts
- Main Function
  - Function 是 C++ 最基礎的單元
  - `main` function 是最重要的起點
- Blocks
  - 由 `{}` 包裹, 用來定義 scope
- Semicolons
  - `;`, 必要的, 代表一段語法的結束
- Identifiers
  - 命名
  - 變數, 函式, 自定義資料型態
- Keywords
  - 保留字
  - 不可以做為 identifiers 使用
- Basic Output `cout`
  - `cout << variable_name;`
- Object-Oriented Programming in C++
  - C++ 支援 procedural-oriented 與 object-oriented programming 兩種範型
  - `class`
  - Data Members
  - Member Functions

C++ Comments

- 註解
- 單行註解, `//`
- 多行註解, `/* */`
- 對於 compiler
  - 註解會被 Lexical Analyzer 過濾掉

C++ Tokens

- 每個在 source code 中的 word 都是 token
- 分類
  - Identifiers
  - Keywords
  - Constants
  - Strings
  - Special Symbols
    - `;`, `[]`, `{}`, `::`, `.`, `=`, `"`, `'`
  - Operators
    - Unary Operators, `++`, `--`
    - Binary Operators
      - Arithmetic Operators, `+`, `-`, `*`, `/`, `%`
      - Comparison Operators, `==`, `!=`, `<`, `>`, `<=`, `>=`
      - Logical Operators, `&&`, `||`, `!`
      - Assignment Operators, `+=`, `-=`, `*=`, `/=`, `%=`
      - Bitwise Operators, `&`, `|`, `^`, `~`, `<<`, `>>`
    - Ternary Operators, `? : ;`

C++ Identifiers

- 獨特的命名, unique name, 來定義 variables, functions, classes, structs, ...
- 命名規則
  - 使用 `A-Z` or `a-z`, `0-9`, `_`
  - 只允許字母或底下作為開頭
  - 不允許使用保留字 (keywords)
  - 在同一個 namespace 下必須是唯一的
  - C++ 是 case sensitive, 大小寫有別

C++ Keywords

- `asm`
- `auto`
- `break`
- `case`
- `catch`
- `char`
- `class`
- `const`
- `continue`
- `default`
- `delete`
- `do`
- `double`
- `else`
- `enum`
- `extern`
- `float`
- `for`
- `friend`
- `goto`
- `if`
- `inline`
- `int`
- `long`
- `new`
- `operator`
- `private`
- `protected`
- `public`
- `register`
- `return`
- `short`
- `signed`
- `sizeof`
- `static`
- `struct`
- `switch`
- `template`
- `this`
- `throw`
- `try`
- `typedef`
- `union`
- `unsigned`
- `virtual`
- `void`
- `volatile`
- `while`

Difference between Keyword and Identifier

---

### 第三章 - C++ Variables and Constants

C++ Variables

- 變數是為一個記憶體空間的命名
- C++ 中變數必須先宣告 (declared) 才能使用
- `type variable_name;`
- 關於 Variable Scopes, 變數可被分成
  - Local Variables, 關於任何 block
  - Instance Variables, 關乎 class
  - Static Variables, 關乎 class, 使用 `static` 進行宣告

C++ Constants

- Constants, 在整個執行期都是固定的值
- Constants 在 C++ 中代表一個變數的值, 在執行期永遠不會改變
- 定義方式有以下三種
- `const`, 來自 C 語法, 在宣告變數時加上前綴 `const` 並且宣告時必須初始化
  - 初始化可以來自於 runtime 或 compile time
- `constexpr` 與 `const` 類似但是, 初始化必須在 compile time 時就知道值
- `#define` 使用 preprocessor 定義常數 (macro constants)
  - preprocessor 進行的事情只是單純的文字替換

Scope of C++ Variables

- Local Variables, 區域變數
- Global Variables, 全域變數
- 當區域變數與全域變數同名時
  - 區域變數優先於全域變數
  - 如果使用 `::` scope resolution operator 作為前綴的話, 可以取得全域變數

C++ Storage Classes

- C++ 儲存類別
- 可以指定變數的儲存類型, 會影響變數 lifetime, scope, initial value 和儲存位置
- 分成六種並且有對應的 keywords
  - auto, 預設模式
  - `register`, C++11 後 deprecated, 暗示 compiler 希望使用 CPU register 儲存
  - `extern`, 預設值為 0, 在任意地方主動定義的 global variable
  - `static`, 預設值為 0, 不會消失, 會一直存活在呼叫處, (例如, 永遠存活在該函式 body 內)
  - `mutable`, class based
  - `thread_local`, thread based, C++11 以後支援

C++ Static Variables

- `static` keyword 使用上可以分成兩種類型
  - Static Variables,
    - 像是在 function body 宣告的 static variable
  - Static Members of Class,
    - 存在 class 內, 由 objects 共享

---

### 第四章 - C++ Data Types and Literals

C++ Data Types

- 所有的變數都需要事先宣告其資料型別, 資料型別讓 compiler 決定要給予該變數多少的記憶體空間
- Data types 的類型可以分為
- Primary, Built-in, Fundamental data type
  - Integer, `int`, `short`, `long`
  - Character, `char`
  - Boolean, `bool`
  - Floating Point, `float`
  - Double Floating Point, `double`
  - Void, `void`
  - Wide Character, `wchar_t`
- Derived data types
  - Function
  - Array
  - Pointer
  - Reference
- User-defined data types
  - Class
  - Structure
  - Union
  - Enum
  - Typedef
- `sizeof()` operator, 取得變數或資料型態的記憶體大小
- Datatype Modifiers
  - Signed, `signed`
  - Unsigned, `unsigned`
  - Short, `short`
  - Long, `long`
- Macro Constants
  - `CHAR_MIN`, `CHAR_MAX`
  - `SCHAR_MIN`, `SCHAR_MAX`, `CHAR_BIT`
  - `MB_LEN_MAX`
  - `SHRT_MIN`, `SHRT_MAX`, `USHRT_MAX`, `INT_MIN`, `INT_MAX`, `UINT_MAX`, `LONG_MIN`, `LONG_MAX`, `ULONG_MAX`, `LLONG_MIN`, `LLONG_MAX`, `ULLONG_MAX`

C++ Literals

- 數值的表示, 分成
- Integer Literals, 整數
  - 沒有小數部分單純的整數, 直接以數字表達
  - 8 進位, 前綴為 `0`, 16 進位, 前綴為 `0x`, 2 進位, 前綴為 `0b`
  - 長整數 (`long int`), 後綴為 `L`, `l`
  - 無號整數 (`unsigned int`), 後綴為 `u`, `U`
  - 長整數 (`long long int`), 後綴為 `ll`, `LL`
- Floating Point Literals, 浮點數
  - `double`, 預設值, 不需要前綴或後綴
  - `float`, 後綴為 `f`
- Character Literals, 字元
  - 包裹在 `' '` 中
- String Literals, 字串
  - 包裹在 `" "` 中
- Boolean Literals, 布林值
  - `true`, `false`

C++ Derived Data Types

- Function, 函式宣告
  - `FunctionReturnType FunctionName(Parameters)`
- Array, 陣列
  - `DataType ArrayName[SizeOfArray]`
  - C++ 陣列宣告時需要提供陣列數量 (固定長度, 記憶體空間)
- Pointers, 指標
  - `DataType* VariableName`
  - 儲存指向指定資料型態的記憶體空間位置
- References, 參考
  - `DataType& ReferenceName = VariableName`
  - 其他變數的別名, (分享相同的記憶體位置)

C++ User-Defined Data Types

- 使用者定義的資料型別
- Class
  - `class ClassName {};`
  - 包含 data members 與 member functions
- Structure
  - `struct StructName {};`
  - 資料型別的聚集
- Union
  - `union UnionName {};`
  - 類似 Structure 但是內部所有的型別分享同一個記憶體空間
- Enumeration
  - `enum EnumName {};`
  - 數字 Enum
- Typedef
  - `typedef TypeName;`
  - 自行定義型別, 建立現有資料型別的別名
  - 用來提供更好的可閱讀性和移植性 (與實際資料結構有介面隔離)

C++ Data Type Ranges and Their Macros

- 使用 C++ macro constants 來取得資料型別的最大與最小值

C++ Type Modifiers

- 修改 primitive data type 的細節
- `signed`, 有號的, 代表能儲存 positive, negative, zero, 多數時候是預設值
  - 適用於 `int`, `char`
- `unsigned`, 無號的, 僅能儲存 non-negative values,
  - 適用於 `int`, `char`
- `short`, 縮小使用的記憶體空間, 也代表縮小能儲存值的範圍,
  - `short int` 等同於 `short`
- `long`, 增加使用的記憶體空間, 也代表增加能儲存值的範圍
  - `long int` 等同於 `long`
- Type Qualifiers, 控制變數值的操作行為
  - `const`, 無法被再次修改的
  - `volatile`, 向 compiler 表達, 該變數可能會被程式本體以外的因素修改, 例如 OS, hardware, ...
    - 調整 compiler 對該變數的優化選項
  - `restrict`, 針對 pointer 變數專用的 modifier,
    - 由工程師保證該 pointer 所指向的對象, 不會被其他 pointer 指向 (保證是唯一 pointer)
    - 避免某些複數個 pointer 指向相同位址的情境, 提升 compiler 優化的選項

C++ Data Type Conversion

- 資料型別轉換, 分成
- Implicit Type Conversion 隱性轉換
  - Compiler 已知的安全轉換 (不會丟失資料)
  - 所有相同的資料類別由小轉大
    - `bool` -> `char` -> `short int` -> `int` -> `unsigned int` -> `long` -> `unsigned` -> `long long` -> `float` -> `double` -> `long double`
- Explicit Type Conversion 顯性轉換
  - 使用者明確表明的型別轉換, 強制轉換, 可能會丟失資料
  - 語法 1. `(type) expression`
  - 語法 2. Cast operator `<type>`, 分成四種類型
    - Static Cast
    - Dynamic Cast
    - Const Cast
    - Reinterpret Cast

C++ Typecasting Operators

- Casting operators 四種類型
- `static_cast <NewType>`
  - Compiler time 的轉換
  - library `typeinfo` 存有函式 `typeid()` 可以協助我們確認型別資訊
- `dynamic_cast <NewType>`
  - 通常用於 Class pointer/reference 進行類別降轉, 會在 runtime 進行確認是否能安全轉換, 無法安全轉換會取得 `null` pointer 或丟出 `bad_cast_exception`
- `const_cast <NewType>`
  - 用於指向 `const` variable 的 pointer
  - 可以通過明確表明 `const_cast` 把 `const` variable pointer 轉換成可以修改值的 non-const variable pointer
  - 小心不可預期的錯誤, **不被推薦使用**
- `reinterpret_cast <NewType>`
  - 不進行任何安全確認的強制轉換
  - 小心不可預期的錯誤, **不被推薦使用**

---

### 第五章 - C++ Operators

---

### 第六章 - C++ Input/Output

---

### 第七章 - C++ Control Statements

---

### 第八章 - C++ Functions

---

### 第九章 - C++ Pointers and References

---

### 第十章 - C++ Arrays

---

### 第十一章 - C++ Strings

---

### 第十二章 - C++ Structures and Unions

---

### 第十三章 - C++ Dynamic Memory Management

---

### 第十四章 - C++ Object-Oriented Programming

---

### 第十五章 - C++ Encapsulation and Abstraction

---

### 第十六章 - C++ Polymorphism

---

### 第十七章 - C++ Function Overloading

---

### 第十八章 - C++ Operator Overloading

---

### 第十九章 - C++ Inheritance

---

### 第二十章 - C++ Virtual Functions

---

### 第二一章 - C++ Exception Handling

---

### 第二二章 - C++ Files and Streams

---

### 第二三章 - C++ Templates

---

### 第二四章 - C++ Standard Template Library (STL)

---

### 第二五章 - C++ Iterators

---

### 第二六章 - C++ Preprocessors

---

### 第二七章 - C++ Namespace

---

### 第二八章 - Advanced C++

---

### 第二九章 - C vs C++

---

### 第三十章 - C++ vs Java

---

### 第三一章 - Competitive Programming in C++

---
